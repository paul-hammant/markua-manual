
# Block Elements

Broadly speaking, Markua documents consist of three things: block elements, span elements and metadata. Paragraphs, headings, figures and lists, all discussed earlier in this specification, are examples of block elements. 

These are the remaining block elements defined by Markua.

## Blockquotes (`>`)

Blockquotes in Markdown are created by prefacing lines with `> `, i.e. a greater than character followed by a space:

~~~
This is the first paragraph.

> This is a blockquote.
>
> It is outside the paragraphs.

This is the second paragraph.
~~~

Blockquotes in Markua are created in one of two ways:

1. By prefacing lines with `> `, i.e. a greater than character followed by a space.
2. By wrapping the blockquote in `{blockquote}` ... `{/blockquote}`

Option #1 is preferable for short quotes; option #2 is easier on authors for really long quotes.

Like figures and tables, blockquotes can be inserted in the middle of a paragraph or as a sibling of it.

A> For non-programmers: I'm calling these things "blockquotes", not "block quotes", since their origin is in Markdown [blockquotes](http://daringfireball.net/projects/markdown/syntax#blockquote), and since they can be inserted by typing `{blockquote}`. If I called them "block quotes", that might encourage someone to incorrectly try to insert them as `{block quote}`, which would not work.

These Markua blockquotes are siblings of the paragraphs:

~~~
This is the first paragraph.

> This is a blockquote.
>
> It is outside the paragraphs.

This is the second paragraph.

{blockquote}
This is a blockquote.

It is outside the paragraphs.
{/blockquote}

This is the third paragraph.
~~~

These Markua blockquotes are nested in the paragraph:

~~~
This is the first paragraph.

This is the second paragraph.
> This is a blockquote
>
> It is inside the second paragraph.
This is part of the second paragraph.
{blockquote}
This is a blockquote.

It is inside the second paragraph.
{/blockquote}
This is part of the second paragraph.

This is the third paragraph.
~~~

A blockquote can contain other block-level elements, most commonly paragraphs.

If you are using the `{blockquote}` ... `{/blockquote}` approach, this is trivial: just pretend you're in a normal paragraph, and the syntax is the same.

If you are using the Markdown approach of `>`, then to start a new block level element within a blockquote, just put a line starting with a `>` followed by a space, followed by the block level element. It is equivalent to placing a `>` and a space in front of every line of the paragraphs.

In Markdown, a single newline inside a blockquote (where both lines are preceded by a `>` and a space) adds a single space. In Markua, however, a single newline inside a blockquote adds a forced line break. This is identical to how single newlines inside a normal Markua paragraph function. This is discussed at length in the [Single Newlines](#single-newlines) section earlier. Note that it means you **cannot** manually wrap blockquotes to make them look nicer. Manually wrapping blockquotes is tedious and discourages editing of your own work. If you have really long blockquotes which span multiple paragraphs, the `{blockquote}` syntax is more pleasant to write in.

Blockquotes can be multi-paragraph. To create a multi-paragraph blockquote, you need to separate each paragraph with a line containing a `>` and (optionally) whitespace.

If a blockquote contains headings, these headings may be formatted by a Markua Processor differently than normal headings. Finally, if a Markua Processor is automatically generating a [Table of Contents](#toc) from chapter and section headings, any headings inside blockquotes should be ignored.

A blockquote can have a citation. This is done via the attribute list, which can include a `cite` attribute with the text of the citation and a `url` attribute with the URL of the citation. If both are specified, the text of the citation is linked to the URL. If only the `cite` attribute is specified it is shown as text; if only the `url` is specified it is inserted as text with a link to itself.

The attribute list can be used regardless of which syntax is used to insert the blockquote:

~~~
Lots of people have opinions about software.

Here's the most famous recent one:

{cite: "Marc Andreessen", url: "http://www.wsj.com/articles/SB10001424053111903480904576512250915629460"}
> Software is eating the world.

It's quoted a lot, so let's quote it again:

{blockquote, cite: "Marc Andreessen", url: "http://www.wsj.com/articles/SB10001424053111903480904576512250915629460"}
Software is eating the world.
{/blockquote}

That's it!
~~~

{#asides}
## Asides (`A>` or `{aside}`)

Since Markua is for writing books, including technical books, it needs not just a syntax for blockquotes--it also needs a syntax for asides and for blurbs. These syntaxes are very similar to the Markua syntax for blockquotes. Like blockquotes, any headings inside asides or blurbs do not show up in a Table of Contents (if one is present), and they can also be formatted differently by Markua Processors.

We will consider asides first.

Asides are typically short or long notes in books which are tangential to the main idea--sort of like footnotes, but in the body text itself. In technical books, quite often they are formatted in a box. Asides can span multiple pages.

The syntaxes for asides are very similar to blockquotes:

1. By prefacing lines with `A> `, i.e. an `A`, then a greater than character (`>`), then a space.
2. By wrapping the aside in `{aside}` ... `{/aside}`

Option #1 is preferable for short asides; option #2 is easier on authors for really long asides.

For consistency with blockquotes, asides can be siblings of paragraphs or nested in them.

Here's a short aside:

~~~
A> This is a short aside.
~~~

Here's a longer aside, which also contains a heading:

~~~
A> # A Longer Aside
A>
A> This is a longer aside.
A>
A> It can have multiple paragraphs.
A>
A> The `A> ` stuff can get tedious after a while.
A>
A> This is why the `{aside}` syntax exists.
~~~

Here's a longer aside using the `{aside}` syntax, which also contains a heading:

~~~
{aside}
# A Note About Asides

This is a longer aside.

It can have multiple paragraphs.

Asides can also have headings, like this one does.

Multi-paragraph asides are more pleasant using this syntax.
{/aside}
~~~

{#blurbs}
## Blurbs (`B>` or `{blurb}`)

Blurbs are like asides, but shorter. A blurb is not intended to span multiple pages of output.

The syntaxes for blurbs are very similar to asides:

1. By prefacing lines with `B> `, i.e. a `B`, then a greater than character (`>`), then a space.
2. By wrapping the blurb in `{blurb}` ... `{/blurb}`

Examples:

~~~
B> This is a short blurb.
~~~

~~~
B> # A Longer Blurb
B>
B> This is a longer blurb.
B>
B> It can have multiple paragraphs.
~~~

~~~
{blurb}
#A Longer Blurb

This is a longer blurb.

It can have multiple paragraphs.
{/blurb}
~~~

### Supported Attributes for Blurbs

Blurbs also have support for an attribute list, which can contain a `class` attribute as well as other implementation-specific "extension attributes".

#### Blurb `class` Types

Markua has its origin in authoring computer programming books. In computer programming books, there are a number of blurb types which are a de facto standard:

* `center`
* `discussion`
* `error`
* `information`
* `tip`
* `warning`

These blurb types can be set on a blurb as its `class` attribute. A Markua Processor can optionally style these blurbs appropriately based on the class, for example by adding custom icons for each class of blurb.

Here's how this looks with the `B> ` syntax:

~~~
{class: warning}
B> This is a warning!
~~~

Here's how this looks with the `{blurb}` syntax:

~~~
{blurb, class: warning}
This is a warning!
{/blurb}
~~~

A> The attribute list must either directly precede the `B>` with no blank line between it and the `B>`, or it must be combined with the `{blurb}` block opening. It is not legal Markua syntax to have an attribute list preceding a `{blurb}` block opening like this:
A> `{class: warning}`
A> `{blurb}`

### Syntactic Sugar for Specific Blurb Classes: `D>`, `E>`, `I>`, `Q`, `T`, `W>`, `X>`

Having to constantly type `{class: warning}` in a computer programming book with a number of warnings would get tedious, as would any of the other blurb classes listed above.

So, Markua defines a standard shorthand syntax for these classes of blurbs. With this syntax, you use a different letter than `B` in the `B>`, to create a blurb with the appropriate `class`.

These are the syntactic sugar values you can use which have a heritage in computer programming books:

| Sugar | Equivalent To a B> With |
|-------|-------------------------|
| `D>`  | `{class: discussion}`   |
| `E>`  | `{class: error}`        |
| `I>`  | `{class: information}`  |
| `Q>`  | `{class: question}`     |
| `T>`  | `{class: tip}`          |
| `W>`  | `{class: warning}`      |
| `X>`  | `{class: exercise}`     |

Examples:

~~~
D> This is a discussion blurb.

E> This is an error blurb.

I> This is an information blurb.

Q> This is a question blurb.

T> This is a tip blurb.

W> This is a warning blurb.

X> This is an exercise blurb.
~~~

These are equivalent to:

~~~
{class: discussion}
B> This is a discussion blurb.

{class: error}
B> This is an error blurb.

{class: information}
B> This is an information blurb.

{class: question}
B> This is a question blurb.

{class: tip}
B> This is a tip blurb.

{class: warning}
B> This is a warning blurb.

{class: exercise}
B> This is an exercise blurb.
~~~

These are *also* equivalent to:

~~~
{blurb, class: discussion}
This is a discussion blurb.
{/blurb}

{blurb, class: error}
This is an error blurb.
{/blurb}

{blurb, class: information}
This is an information blurb.
{/blurb}

{blurb, class: question}
This is a question blurb.
{/blurb}

{blurb, class: tip}
This is a tip blurb.
{/blurb}

{blurb, class: warning}
This is a warning blurb.
{/blurb}

{blurb, class: exercise}
This is an exercise blurb.
{/blurb}
~~~

Note that `Q>` and `X>` are a bit controversial:

* `Q>` defines a blurb which is formatted like a question, but `{quiz}` (discussed later) defines a quiz, and quizzes have actual numbered questions in them. It is unfortunate that the words `quiz` and `question` both start with the letter `Q`, and that the `question` blurb is not the same thing as a question in a quiz.
* `X>` defines a blurb which is formatted like an exercise, but `{exercise}` (discussed later) defines a structured exercise similar to a quiz. It is unfortunate that the term "exercise" is used for both.

There are issues, in both cases. However, the alternative is worse: removing the `Q>` or `X>` syntax would cause issues for every author who is familiar with, or has a manuscript formatted in, Leanpub Flavoured Markdown. This is not worth the reduced functionality, just to avoid one possible bit of confusion and one naming collision. So, the `Q>` and `X>` blurb syntactic sugar do exist, as do the `{class: question}` and `{class: exercise}` full blurb syntaxes.

Also note that nothing in this section defines what a Markua Processor must *do* with the given class of blurb. Leanpub, for example, uses it to add an appropriate icon from [Font Awesome](https://fortawesome.github.io/Font-Awesome/) at the left of the blurb, but other Markua Processors are free to do something different.

Finally, note that specifying a class in metadata overrides what the syntactic sugar does:

~~~
{class: tip}
W> This is a tip blurb, not a warning blurb.
~~~

A Markua Processor is free to either override this silently, or to raise an error if this happens.

### Using Blurbs to Center Text with `C>`

You can also use a blurb to center text.

The following two ways to do this are equivalent:

~~~
C> This is a centered blurb.

{class: center}
B> This is a centered blurb.
~~~

This is the only way to center text in Markua.

Unlike other blurb types which have their origin in technical books, centering text has a wide range of uses. So, it could have been thought of as something different than a blurb. However, in terms of its behaviour and the way it's inserted, centered text is a blurb--whether it's inserted via syntactic sugar or via a class attribute on a normal blurb element. So, it's discussed here.

### Using Extension Attributes on Blurbs to add `icon` Support

Markua Processors must ignore any attributes which they do not understand.

Because of this, Markua attribute lists can contain any number of extension attributes. An extension attribute is an attribute which is not defined in the Markua specification, but which is understood by some specific Markua Processor.

As an example of an extension attribute, Leanpub adds an `icon` attribute to blurbs. Markua does not specify that a blurb must support an `icon` attribute, or what it would mean if it did. However, Leanpub understands an `icon` attribute to reference an icon from Font Awesome. The value of this attribute is assumed to be the name of an icon in Font Awesome, without the `fa-` prefix.  So, in Leanpub, you can do this:

~~~
{icon: car}
B> You can't spell carbon without it!

{icon: leanpub}
B> Yes, we're in Font Awesome!

{icon: github}
B> So is GitHub, of course. Unicorns.
~~~

In Leanpub, this will produce a nice icon of a car, using the Font Awesome icon. In a Markua implementation that does not understand the icon attribute, nothing will be generated for that attribute--it will be functionally equivalent to the attribute not being present.

{#inserting-into-paras}
## Inserting Block Elements Inside Paragraphs

Many block elements such as lists and figures can also be inserted nested in a paragraph. The way this is done is to add single newlines instead of blank lines.

This example shows a list nested in the middle of a paragraph:

~~~
This is paragraph one.

This sentence is in paragraph two.
* this list is
* part of
* paragraph two
This sentence is also in paragraph two.

This is paragraph three.
~~~

This example shows a figure which is an inline code resource nested in the middle of a paragraph:

~~~
This is paragraph one.

This sentence is in paragraph two.
```ruby
puts "hello world"
```
This sentence is also in paragraph two.

This is paragraph three.
~~~

This example shows a figure which is a local code resource nested in the middle of a paragraph:

~~~
This is paragraph one.

This sentence is in paragraph two.
{format: ruby}
![Hello, World](hello.rb)
This sentence is also in paragraph two.

This is paragraph three.
~~~

This example shows figures which are local or web image resources nested in the middle of paragraphs. Note that as with all figures, the square bracket text in both cases is the figure caption (not alt text):

~~~
This is paragraph one.

This sentence is in paragraph two.
![A Piece of Cake](cake.jpg)
This sentence is also in paragraph two.

This sentence is in paragraph three.
{alt: "a slice of chocolate cake"}
![A Piece of Cake](http://markua.com/cake.jpg)
This sentence is also in paragraph three.

This is paragraph four.
~~~

It is possible to insert a block element as the last part of a paragraph by adding a single newline before it, but a blank line after it:

~~~
This is paragraph one.

This sentence is in paragraph two.
* this list is
* part of
* paragraph two

This is paragraph three.
~~~

This works for most block elements, like lists, figures and tables. It does **NOT** work for definition lists, since those rely on blank lines in between elements.

## Quizzes and Exercises

The final two block elements that Markua provides are quizzes and exercises. These two block elements are very special, however, in that they enable a single Markua document to construct everything from traditional textbooks and paper-based quizzes to entire online courses (or MOOCs). So, they're discussed in [their own chapter](#courses).

# Span Elements

We've already seen many examples of span elements in this specification, especially in the resources section showing resources inserted as spans. These are the rest of them...

## Links

Markua's hyperlink support is a subset of that of Markdown. The **inline** link syntax is supported, as is the **automatic link** shortcut.

### Inline Links

The normal way to create a link is as follows:

~~~
[link text](absolute_url)
~~~

Example:

~~~
Markua was developed at [Leanpub](http://leanpub.com).
~~~

### Automatic Links

To create a link where the text displayed for the link text is the URL itself, the automatic link syntax can be used. In this syntax, an absolute URL is enclosed in angle brackets.

~~~
Some text <absolute_url> some text.
~~~

Example:

~~~
Markua was developed at <http://leanpub.com>.
~~~

## Explicitly Creating Spans with `[`...`]`

Surrounding text in square brackets can be useful not just for giving it a URL to link to. If you wish to add attributes to an arbitrary span of text, you can create an arbitrary span of text using square brackets and then add an attribute list immediately afterward:

~~~
Some text [then a span]{and: an, attribute: list} attached to the span.
~~~

You can use any attribute list on this span, and you can also just use the id syntactic sugar `{#theid}` on this span. The most common uses of this are to add `id`s or index entries, which are discussed later.

Note, however, that you cannot start a normal span with a caret (`^`): this creates a `[^footnote]` instead. (Footnotes are discussed below.)

### Sometimes a Square Bracket is Just a Square Bracket

If there are no round brackets or curly braces immediately after some text in square brackets, the text in square brackets is just that: text in square brackets. In this case, the square brackets are output as normal text.

This is useful when you want to [sic.] something, etc.

## Footnotes and Endnotes

### Footnotes

Books often have footnotes.

To add a footnote, you insert a footnote tag using square brackets, a caret and the tag, like this:

~~~
This has a footnote[^thenote].
~~~

Then, you define the footnote later in the document, using the same square brackets, caret and tag, followed by a colon, a space and the footnote definition:

~~~
[^thenote]: This is the footnote content.
~~~

If you wish to write multiple paragraphs in the footnote, you must indent the subsequent paragraphs by four spaces or one tab:

~~~
This has a footnote[^thenote].

Here is some unrelated text.

[^thenote]: This is the first paragraph of footnote content.

    This is the second paragraph of footnote content.

Here is some more unrelated text.
~~~

Whether the numbering of footnotes restarts every chapter is something that can be specified by the [`restart-footnote-numbering`](#setting-keys-and-values) setting.

### Endnotes

Books often have endnotes. Sometimes these are instead of footnotes, but other times, these are in addition to footnotes. So, it makes sense for Markua to define separate syntaxes for both, rather than just defining one "footnote or endnote" syntax and letting the author pick whether the notes are footnotes or endnotes via a global setting.

To add an endnote, you insert an endnote tag using square brackets, two carets and the tag, like this:

~~~
This has an endnote[^^thenote].
~~~

Endnotes are like footnotes, but happier (`^^`).

Then, you define the endnote later in the document, using the same square brackets, two carets and tag, followed by a colon, a space and the endnote definition:

~~~
[^^thenote]: This is the endnote content.
~~~

Just as with footnotes, if you wish to write multiple paragraphs in an endnote, you must indent the subsequent paragraphs by four spaces or one tab.

Whether the numbering of endnotes restarts every chapter is something that can be specified by the [`restart-endnote-numbering`](#setting-keys-and-values) setting.

### Single Reference to Footnotes and Endnotes

You can only refer to a footnote or endnote once. You can't define a footnote or endnote in one place and refer to it multiple times in the same Markua document. If you wish to refer to a parenthetical piece of text from multiple places in a Markua document, the best approach is to put it in a section (or sub-section, sub-sub-section, etc.) or aside and refer to it from multiple places using a [crosslink](#crosslinks).

### Footnotes and Endnotes Support Required for Paragraphs Only

A Markua Processor must support footnote and endnote references inserted in normal paragraph content. However, that's it.

However, sometimes authors want to get creative with their footnotes and endnotes. Sometimes they want to add them in headings, or in footnotes or endnotes themselves. This latter style has been used on rare occasions, most notably by David Foster Wallace.

However, supporting inserting footnotes and endnotes in places other than normal paragraph content puts a hugely increased burden on implementors of Markua Processors. As such, there is no requirement for a Markua Processor to support inserting a footnote or endnote anywhere other than in normal paragraph content.

Authors should **not** assume that a particular Markua Processor supports inserting a footnote or endnote anywhere other than in normal paragraph content unless its documentation specifically states that it does. For example, Leanpub only supports inserting footnotes or endnotes in normal paragraph content.

A> In software, [abstractions leak](https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/). Leanpub uses LaTeX for its PDF generation, and presumably many other Markua Processors will as well. In LaTeX, inserting footnotes or endnotes in places like headings, footnotes or endnotes is very problematic. So, it's optional. The best thing about writing a specification for something you are implementing is that there is often a very easy solution to a very difficult implementation problem!

{#crosslinks}
## Crosslinks and ids

There are two parts to making a crosslink.

1. Define an id.
2. Reference that id with a crosslink.

### Defining an id

There are two ways to define an id:

1. Using an id attribute `{id: some-id}`
2. Using a shorter "syntactic sugar" approach: `{#some-id}`

The shorter "syntactic sugar" approach is usually preferred. However, it can look a bit odd in an attribute list with other attributes in it. So, in that case, the `{id: some-id}` syntax is preferred.

W> Note for Leanpub authors: The `{#some-id}` syntax does not currently work when there are other attributes in the attribute list. So, in that case, you must currently use the `{id: some-id}` syntax if you are adding other attributes in a larger attribute list. You currently **CANNOT** add the `{#some-id}` to an attribute list.

In terms of the value of an `id`, it has some special restrictions:

1. The first character in the `id` has to be a lowercase or uppercase letter, i.e. `[a-zA-Z]` if you think in regular expressions.
2. The remaining characters in the `id` have to be a lowercase or uppercase letter or a digit or a hyphen (-) or an underscore (_).
3. You can only define an `id` value once in an entire Markua document, even one that is split over multiple files.

These restrictions ensure that your `id`s can then be linked to by a crosslink from anywhere in the Markua document.

The id needs to be defined on either a block or span element.

A> If an id is defined with an invalid name, the Markua Processor must ignore it and log an error.

#### Defining an id on a Block Element

To define an id on a block element like a paragraph, figure, heading or even a definition list item, you simply stick the id definition on a line above the start of the block element. Note that exactly one newline must separate the attribute list from the block element--if two newlines are used, the attribute list will be interpreted as a directive, and the id won't be correctly applied.

Here's how to use the attribute list syntax to define an id attribute:

~~~
{id: some-id}
This is a paragraph with the id of `some-id`.
~~~

Here's how to use the shorter "syntactic sugar" approach to define an id attribute:

~~~
{#some-id}
This is a paragraph with the id of `some-id`.
~~~

#### Defining an id on a Span Element

To define an id on a span element you simply add the id definition immediately after the span element.

Here's how to use the attribute list syntax to define an id attribute on a span element:

~~~
The word Markua{id: markua} has an id.

Leanpub is based in **Victoria, BC, Canada**{id: victoria}.
~~~

Here's how to use the shorter "syntactic sugar" approach to define an id attribute:

~~~
The word Markua{#markua} has an id.

Leanpub is based in **Victoria, BC, Canada**{#victoria}.
~~~

Here's how to define an id on a custom span:

~~~
The [quick sly fox]{#quick_sly} jumped over the lazy dogs.
~~~

If you want to define an id on a span while also defining other attributes like index entries, the `id:` syntax must be used in a full attribute list:

~~~
The [quick sly fox]{id: quick_sly, i: "Fox, Sly and Quick"} jumped over the lazy dogs.
~~~

### Referencing an `id` With a Crosslink

Regardless of how you defined the id, you then link to it to create a crosslink. To do this, you use the `#` character and the id in a link:

~~~
[link text](#some-id)
~~~

This syntax is intended to be reminiscent of HTML anchor tags, not of `h1` titles in Markua.

Note that order of definition and use does not matter: crosslinks will work regardless of whether the `id` is defined before or after the use of it.

### Rules for `id`s and Crosslinks

* If a Markua document contains duplicate `id` attribute values, the **first** one is used and the subsequent ones are ignored. A Markua Processor should log an error about duplicate `id`s.
* Crosslinks that reference an unused `id` may either be created as a (broken, non-functional) link or be created as normal text (not a link) by a Markua Processor. The Markua Processor should also log an error.

### Referencing Chapter, Section and Figure Heading Names and Numbers in Crosslinks

W> Leanpub authors: this has not been implemented yet

Chapters, sections and figures with captions often have two useful properties for writers:

1. A name which is often short and useful to reference.
2. A number, if numbering is turned on.

Whether the numbers exist is determined by the `number-chapters`, `number-parts` and `number-figures` attributes .

In your writing, it's often desirable to refer to these figures from elsewhere in your book. When creating such a reference, it's helpful to be able to reference the title and number of the chapter, section or figure.

A> Adding a reference to the page number would also be helpful in print, but it is obviously problematic in an ebook, since certain ebook formats have resizable text and since the page displayed by PDF readers is often different than the printed page number, because of front matter Roman numerals. So, Markua doesn't provide any special magical syntax to refer to a page number, in order to discourage it--if Markua did support a reference to a page number, then the next logical step would be to only do so in certain output formats, and then writing Markua text would feel like programming. Instead of this nightmare, a really smart Markua Processor could hypothetically (and with the author's permission) automatically add page number references to these references when producing a print-ready PDF.

Here's how these references to titles and numbers work:

* `#t` is for "title"
* `#n` is for "number"
* `#d` is for "description" (e.g. "Figure", "Chapter", "Section")
* `#f` is for "full title"

So, for "Figure 8.2: Anatomy of a Squirrel", these are:

* `#t` is "Anatomy of a Squirrel"
* `#n` is "8.2"
* `#d` is "Figure"
* `#f` is "Figure 8.2: Anatomy of a Squirrel"

Note that in this example, "Anatomy of a Squirrel" was typed by the author, whereas "Figure 8.2: " was generated by the Markua Processor. It does not matter; both can be referenced.

Also, note that regardless of section level, sections referenced in `#d` or `#f` are all called "Section" (not "Sub-Section", "Sub-Sub-Section", etc.)

The expectation is that `#f` will be used by authors who don't mind verbosity, and #t and #n will be used by authors who prefer control and brevity. The #d is for very lazy authors who like saving keystrokes and/or who don't know whether their publisher will call the code samples "Listing", "Example" or some other word and want to protect themselves against extra work.

The `code-sample-names`, `figure-names` and `table-names` settings control the words used to name things.

Examples:

~~~
This is discussed in [section #n, #t](#crosslinks).

This is discussed in [#f](#crosslinks).

This is discussed in a [#d](#crosslinks) above.

See [chapter #n](#span-elements), which is the best chapter in this book.

This is in figure [#n](#fancy-diagram), arguably the fanciest diagram in this document.
~~~

The only way to reference the title and numbers is in crosslinks. There's no syntax to do so without creating a crosslink--a crosslink is more helpful, since it is clickable, and adding another syntax simply to be less helpful to the reader is a bad idea. Markua has enough syntax as it is.

Note that resources, chapters and sections all have implicit numbering. So, #n always works even if numbering is off. However, you will confuse readers if you refer to numbering they cannot see. Also, if numbering is off, the `#f` must not include either the `#d` or `#n` parts: it will be "Anatomy of a Squirrel" not "Figure 8.2: Anatomy of a Squirrel".

{#charsub}
## Character Substitution

 All Markua documents are written in UTF-8, so to produce any Unicode character, it possible to just use the proper Unicode characters. However, in certain cases, it's desirable for Markua to specify automatic replacement of certain combinations of characters with a Unicode replacement. If a Markua Processor encounters one of these combinations of characters outside of a code block, the Markua Processor must replace the combination of characters with the appropriate Unicode character in the output.

`--`
: To produce an em dash (—), what is thought of by non-typography people as a "dash" or a "long dash", you can just type two hyphens (`--`) directly after a non-space character. You can also use the proper Unicode character, U+2014, of course. The following all produce em dashes: `foo--bar, foo-- bar, foo--`.

` --`
: To produce a space followed by an en dash (–), or the kind of dash that's wider than a hyphen but narrower than an em dash, you can just type a space, followed by two hyphens (` --`). You can also use the proper Unicode character, U+2013, of course. The following both produce en dashes preceded by spaces: `foo -- bar, foo --`. (With `foo -- bar`, there's a space before and after the en dash; with `foo --`, there's no space after it (e.g. at the end of a paragraph).

`...`
: To produce a horizontal ellipsis (…), you can just type `...`. You can also use the proper Unicode character, U+2026, of course.

### Optional Automatic Curly Quotes Outside of Code Blocks and Spans

A Markua Processor may replace the `"` character with the appropriate "curly quote" at its discretion. This lets `"typography"` become `“typography”`, and `it's` become `it’s` as appropriate.

Note that this is an optional behaviour: a Markua Processor may support this fully, only in some output formats, or not at all.

Also, note that it is **NEVER** acceptable for a Markua Processor to do this, or *any* character substitution, to text inside a code block or code span. In almost all instances this would completely break the code. (If you wonder how I got curly quotes into the code spans for `“typography”` and `it’s` above, it's because I pasted them into the manuscript that way. Just as a Markua Processor doesn't make straight quotes curly in a code span, it doesn't make curly quotes straight in a code span either.)

## Escaping Special Characters with Backslash (`\`)

Curly braces and backticks are special in Markua.

A backslash can "escape" a single character, to prevent it from having any special meaning.

TODO - broaden backslash escape (see CommonMark vs Markdown).

At the beginning of a line, an opening curly brace (`{`) starts an attribute list, and two opening curly braces (`{{`) start a placeholder. In the middle of a block element, an opening curly brace starts an index entry. And, at the top of a manuscript.txt file (if the single file approach is used), an opening curly brace starts a settings block.

So, to use a curly brace as an actual curly brace character, you need to backslash-escape it like this: `\{`. (Note that this does not apply inside code or other resources: Markua does not process anything inside them.)

Similarly, a backtick is special. In text content (such as this paragraph), a backtick starts an inline span resource such as a code resource. And three backticks on a line by themselves start a code block.

## Backticks (`` ` ``)

You can create a code span by using pairs of 1, 2 or 3 backticks to surround a span of text within a paragraph, like this:

~~~
This paragraph has a Ruby `puts "hello"` code span inside it.
~~~

You cannot show a literal backtick in a normal code span, however, since you cannot backslash escape anything inside it. Inside a code span, a backslash is just a backslash.

~~~
This paragraph has a Ruby `puts "hello\tworld"` code span inside it.
~~~

So, if you want to output a backtick in a code span, you need to delimit the code span using two backticks:

~~~
This paragraph has a code span with literal backticks `` `say hello` `` in it.
~~~

{#unicode-entities}
## Unicode Entities with `\u`

Typing obscure Unicode characters is hard. So, markup and programming languages often support outputting entity references to Unicode characters. For example, consider the unicode character with the code point `U+1F602`. In HTML, this is the entity `&#x1F602;` in hexadecimal or `&#128514;` in decimal. In JavaScript and many programming languages it is `\u1F602`. These code points are specified in UTF-16, which is a hexadecimal number containing 16-bits of information.

Markua supports Unicode entity references as well. To output a Unicode character, you can type a backslash (`\`), followed by a `u`, followed by the hexadecimal value of the Unicode code point, followed by a semicolon. For example, you can type `\u1F602;` in Markua. The reason the semicolon is required is to clearly indicate the end of the Unicode hexadecimal value to the Markua Processor.

Some example unicode entities which may be useful for a Markua Processor to support include:

* Soft hyphen: \u00AD;
* Non-breaking space: \u00A0;

Now, there's no guarantee that a given Unicode character will be present in a given font.

If a Markua Processor recognizes that a given Unicode character is not present in the font it is currently using, it may switch to a font that it knows will support that character. However, it is entirely acceptable for a Markua Processor to not do anything fancy, and to just attempt to output the character in the font it is using. In this case, what will typically happen is that the font will output a box in place of the missing character. These boxes are affectionately referred to as "tofu" by font people. (You may also encounter a diamond with a question mark in it in this case.)

## Internationalization

Markua Processors may detect the language of the Markua document and output various text in the correct manner. This includes the localization of things like punctuation, the table of contents, etc.

{#emoji}
## Emoji

In 2015, emoji fully arrived. The 2015 Oxford Dictionaries Word of the Year [was](http://blog.oxforddictionaries.com/2015/11/word-of-the-year-2015-emoji/), in fact, the Face with Tears of Joy emoji. You may think of it as a smiling face with tears of joy, but you can also can think of it as `\u1F602;`, which is its Unicode code point.

However, Unicode characters aren't the only way to do emoji. Another popular syntax for emoji is `:emoji_name:` -- that is a colon (`:`), followed by the underscore-separated name of the emoji, followed by a colon.

What should Markua do?

Well, first of all, this is *fantastic* news. Emoji are the single legitimate use case for an inline span image, but any syntax I could invent to specify alt text on an inline span image was either disgusting or was inconsistent with how images are inserted as figures with figure captions.

So, now that emoji are on the rise and have two syntaxes to support them, this problem is solved: emoji can be inserted using either Unicode entities or the special emoji syntax, and the output generated by a Markua Processor is (hopefully) the emoji. So, there's no need for an inline span image syntax!

Markua handles both emoji syntaxes, but it handles them differently.

For the Unicode entity syntax, you just type the Unicode entity. For example, you could write the following sentence:

~~~
The emoji support in Markua makes me \u1F602;
~~~

Again, as discussed [above](#unicode-entities), there is no requirement for a Markua Processor to support a given Unicode character.

With the `:emoji_name:` syntax, a similar, slightly less happy, sentence would be:

~~~
The emoji support in Markua makes me :smile:.
~~~

When outputting a sentence containing emoji inserted using the `:emoji_name:` syntax, the Markua Processor can either:

1. Output the emoji as a span image (right in the flow of the text with no line breaks before or after it) with the `:emoji_name:` (including the colons) as alt text.
2. Output the emoji using an emoji-aware font, having mapped the emoji name to some Unicode code point using some canonical table somewhere. There are online resources such as <http://www.webpagefx.com/tools/emoji-cheat-sheet/> which may be a starting point for any Markua Processor wishing to do this.
3. Output the `:emoji_name:` as an inline code span showing the `:emoji_name:` verbatim.
4. Output a "missing image" character, if it does not recognize the given emoji.

Because of this, Markua's emoji support can also optionally be used by Markua Processors for a wide range of emoji. For example, a Markua Processor could output Font Awesome icons with an emoji syntax, such as `:fa-leanpub:` to output the Leanpub logo in Font Awesome. Since all Font Awesome icons have an `fa-` prefix, these are namespaced nicely.

## Placeholders

Placeholders are a simple text-replace templating system which allow you to define boilerplate in one place, and easily insert it in other places. For books like novels, these obviously have no place. However, for books, courses and other types of documents produced by large organizations, there is an absolute need for placeholders.

Since this is a fairly niche requirement, the syntax is designed in a way that authors should never inadvertently trigger it unless they intend to. It is similar to the footnote syntax.

Placeholder definitions can occur before or after the placeholder insertions. Implementors of Markua Processors are encouraged to deal with placeholders in a pre-processing step.

Placeholders can be defined and inserted as span or block elements.

### Placeholder Identifiers

The identifier for a placeholder must conform to `/[a-zA-Z][a-zA-Z0-9_-]*/`. That is, it starts with a lowercase or uppercase letter `[a-zA-Z]`, followed by 0 or more letters, numbers, underscores or hyphens `[a-zA-Z0-9_-]*`.

### Span Placeholders

#### Span Placeholder Definition

To define a span placeholder, you create a block element consisting of two opening curly braces (`{{`), followed by the placeholder identifier, followed by two closing curly braces (`}}`), followed by a colon (`:`), followed by one space, followed by the span placeholder definition:

~~~
other stuff

{{a_span_placeholder}}: This is the span placeholder definition which can have **Markua formatting** and reference {{other_span_placeholders}} but not block placeholders.

other stuff
~~~

A span placeholder definition can have Markua formatting and can reference other span placeholders.

However, block placeholder references and circular placeholder references are obviously forbidden as content of span placeholder definitions.

#### Span Placeholder Usage

A span placeholder can then be used either in a span context or in a block context.

Specifically, to insert a span placeholder, you use two opening curly braces (`{{`), followed by the placeholder identifier (composed of `a-zA-Z_-` characters), followed by two closing curly braces (`}}`).

~~~
Here's a span placeholder as the only content of a block:

{{a_span_placeholder}}

Here's the same span placeholder {{a_span_placeholder}} being used in a span context.
~~~

### Block Placeholders

#### Block Placeholder Definition

To define a block placeholder, you create a block element consisting of two opening curly braces (`{{`), followed by the placeholder identifier, followed by two closing curly braces (`}}`), followed by the block placeholder content, followed by a newline, followed by two opening curly braces (`{{`), followed by a forward slash (`/`), followed by the placeholder identifier, followed by two closing curly braces (`}}`):

~~~
other stuff

{{a_block_placeholder}}
This is the placeholder content.

It can include *any type of Markua formatting* and can **even** include {{span_placeholder_references}}.

It can also include block placeholder references:

{{some_other_block_placeholder}}

Note that circular placeholder references are obviously forbidden.
{{/a_block_placeholder}}

other stuff
~~~

#### Block Placeholder Usage

A block placeholder can then be used only in a block context. It cannot be used in a span context.

Specifically, to insert a block placeholder, you use two opening curly braces (`{{`), followed by the placeholder identifier (composed of `a-zA-Z_-` characters), followed by two closing curly braces (`}}`). The only difference is that this must be in a block context by itself, with at least one blank line above or below it.

~~~
Here's a block placeholder as the only content of a block:

{{a_block_placeholder}}

You cannot insert that block placeholder in a span context like in this paragraph.
~~~

{#whitespace-hack}
## A Hack for Forcing Whitespace

Inside a code span or block, whitespace must be preserved by a Markua Processor. So, if you're trying to insert a bunch of whitespace for some strange reason, there is a straightforward hack to do so.

So, there are five spaces between foo and bar here, three inside the backticks, and two outside them: foo `   ` bar. Similarly, there are five blank lines between these two paragraphs:

~~~
Yada yada yada

```



```

Yada yada yada
~~~

You can also use the poetry block syntax, if you want your whitespace to be more poetic:

~~~
Yada yada yada

---



---

Yada yada yada
~~~

Again, this is a total hack. It should not be used to accomplish pagination or otherwise format a Markua document. However, if you want to do it, now you know how to do it.

{#concatenating}
## Concatenating Files and Blank Lines

A Markua document can be written in one file or multiple manuscript files. If a manuscript is written in multiple files, these files are concatenated together by the Markua Processor to produce one temporary manuscript file, and that one file is used as the input.

Importantly, in order to avoid a number of bugs, the files are not just concatenated together unchanged--they **must** be concatenated together by Markua Processors in the following way:

1. All newlines at the beginning and the end of each file are removed.
2. Two newlines are added between the end of each file and the beginning of the next file.

So, after this process, exactly one blank line separates the contents of each manuscript file.

This prevents a number of surprises for authors, and is consistent in design: just as Markua does not support invisible formatting at the end of a line, it does not support invisible formatting at the end of a file.

Note that because of this rule, a paragraph (or any other block element) cannot span multiple manuscript files.

To see why this approach is so important, consider the following single-file Markua document:

{caption: manuscript.txt}
~~~
# Chapter One

Lorem ipsum dolor.

# Chapter Two

Yada yada yada.
~~~

Suppose instead a multiple-file approach was used, in which there were two files, ch1.txt and ch2.txt, with the following content:

{caption: ch1.txt}
~~~
# Chapter One

Lorem ipsum dolor.
~~~

{caption: ch2.txt}
~~~
# Chapter Two

Yada yada yada.
~~~

If Markua did not add any newlines between files, then these files would produce the following incorrect manuscript:

{caption: incorrect concatenation}
~~~
# Chapter One

Lorem ipsum dolor.# Chapter Two

Yada yada yada.
~~~

If Markua only added one newline when concatenating, this would produce the following incorrect manuscript:

{caption: also incorrect concatenation}
~~~
# Chapter One

Lorem ipsum dolor.
# Chapter Two

Yada yada yada.
~~~

However, since Markua requires that headings be separated by blank lines above and below them, the Chapter Two heading would not be a heading. It would be considered part of the previous paragraph! This would be very surprising and the source of a number of bugs. Worse, since a number of text editors such as Emacs have a "strip blank lines at the end of files" setting, it would be possible to introduce such a bug if Markua simply relied on blank lines being added to the end of a file by the author.

So, because of the blank line rule, concatenating the files produces the same manuscript as the single-file manuscript above:

{caption: correct concatenation}
~~~
# Chapter One

Lorem ipsum dolor.

# Chapter Two

Yada yada yada.
~~~

