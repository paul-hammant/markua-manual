## Resources

Markua documents are written in plain text, either in one text file or multiple text files. However, modern books and courses sometimes contain more than text. Books and courses may embed many types of *resources*.

Resources include things like images, but also include tables, code samples, math, poetry, and even audio and video. (Obviously you can't output audio and video in a book. But a Markua Processor can do smart things, including placeholder images and providing URLs. For an ebook or course, these can be links, or can trigger launching audio or video apps, etc. There is a lot of flexibility for a Markua Processor to do a lot of fancy things with resources, but the important point is that this is extremely simple for the Markua author to use: they just refer to a resource.)

Each type of resource has a number of supported formats. Markua's goal is to make inserting all types of resources simple and consistent, while staying as close to Markdown's syntax as possible.

Resources vary in four different ways:

1. **Insertion Methods**: Span and Figure
2. **Locations**: Local, Web and Inline
3. **Types**: `audio`, `code`, `image`, `math`, `poetry`, `table` and `video`
4. **Formats**: `png`, `m4a`, `mp3`, `ruby`, `latex`, etc.

Before going into more detail, it's helpful to consider a brief example of Markua text which shows a number of resources being inserted. These resources have different insertion methods (span and figure), different locations (local, web and inline), different types (image, code) and different formats (png, jpg, ruby)--yet the syntax to insert them is compact and consistent:

~~~
Inserting an image as a figure is...

![A Piece of Cake](http://markua.com/cake.jpg)

Inline code resources are added as spans like this `hello world` or as figures.

```ruby
puts "hello world"
```

{format: ruby}
![Hello, World](hello.rb)
~~~

The last figure in the example above showed an **attribute list**, which is a list of key-value pairs in curly braces. Any figure can have an attribute list, regardless of resource location, type or format. Attribute lists are explained [later](#attributes).

If you're familiar with Markdown syntax, you'll note that the syntax for local and web resources is similar to Markdown's inline image insertion syntax, and that the syntax for inline resources is similar to the fenced code blocks syntax from popular Markdown extensions and dialects including GitHub Flavoured Markdown.

Tables are also resources, and can also be local, web or inline. However, the table syntax is more elaborate than the syntax for the other resource types, so we discuss tables [later](#tables).

Finally, if any resource is missing during book generation, a Markua processor can either fail to generate the book or can insert something like the "missing image" often seen on web pages into the book. People building Markua Processors have a lot of freedom here.

### Resource Insertion Methods

Resources can be inserted either as figures or as spans.

#### Figures

All resources can be inserted as figures. Figures are the normal case for how a resource is inserted. In many Markua documents, they will be most or all of the resources.

To insert a resource as a figure, there must be at least one newline before and after it.

A figure can either be top-level (with a blank line before and after it), or it can be contained in a paragraph. The ways that figures and other block elements can be inserted in paragraphs is discussed [later](#inserting-into-paras).

The syntax for a local or web resource inserted as a figure is as follows:

~~~
{key: value, comma: separated, optional: attribute_list}
![Optional Figure Caption](resource_path_or_url)
~~~

The syntax for an inline resource inserted as a figure is as follows:

~~~
{key: value, comma: separated, optional: attribute_list}
```optional_format
inline resource content (default format is `guess`)
```
~~~

Note that you can also insert an inline resource as a figure using tildes as the delimiter. If the only delimiter was backticks, it would be really difficult to write about Markua in Markua. This syntax is as follows:

```
{key: value, comma: separated, optional: attribute_list}
~~~optional_format
inline resource content (default format is `text`)
~~~
```

Note that **exactly** three backticks or three tildes must be used to insert an inline resource as a figure. If more backticks or tildes are used, these will be interpreted as normal text.

##### Figure Attributes

A figure can also have attributes. The supported attributes vary based on the type of resource, but **all** resources inserted as figures support the `caption`, `class`, `format`, `title` and `type` attributes. (As such, these five attributes are not shown on the specific resource types below.)

`caption`
: This is text which is shown near the figure, typically above or below it. A Markua Processor can choose where to position captions based on any criteria it chooses. For example, a Markua Processor can position all captions above or below figures, or use a different behaviour based on the resource format (e.g. table captions above, image captions below). Note that the figure caption itself may contain the Markua text formatting specified earlier in the [Text Formatting](#text-formatting) chapter. If no `caption` is provided but a `title` is provided, then the `title` should be used as the caption: it does not make sense to refer to a figure with a title, but for the figure itself to have no caption.

`class`
: All attribute lists support a `class` attribute. When used in figures, this is the class of the figure. This can be used for styling, and it can also be used by Markua Processors which group figures by classes, such as theorems or lemmas.

`format`
: This is the resource format. Different resource types have different legal values for format.

`title`
: This is text which is displayed for the figure wherever the figure is listed (e.g. List of Illustrations, Table of Tables, etc.). If no `title` is provided, the `caption` should be used in those places.

`type`
: This is the resource type. This is usually inferred from the format instead of being specified.

Figures can have both alt text and a figure caption. These are distinct things. We will discuss the figure caption first and the alt text second.

##### Figure Captions

A resource which is inserted as a figure can have a figure caption.

This caption shows up in two places in the output:

1. Near the resource, typically above or below it, per the preference of the Markua Processor.
2. Based on the resource type, either in the List of Illustrations, List of Tables or Table of Figures, if they are generated for the book. This text should also be a crosslink to the caption inserted near the figure itself.

The caption for a figure can provided in one of two ways:

1. In the square brackets in front of a local or web resource.
2. In the attribute list above the resource.

~~~
![My Amazing Algorithm](algorithm.rb)

{caption: "My Amazing Algorithm"}
![](algorithm.rb)
~~~

The first choice is clearly shorter, as well as more pleasant to write and to read.

Since inline resources do not use the square bracket syntax, any captions must be added in the attribute list:

~~~
Here's a paragraph before the figure.

{caption: "My Amazing Algorithm"}
```ruby
puts "hello world"
```

Here's a paragraph after the figure.
~~~

##### Figure Alt Text

A figure can have alt text, as long as the type of resource being inserted supports alt text. The alt text is always defined in an attribute list above the figure. Since the alt text is defined in the attribute list, the resource location does not matter: local, web and inline resources all support alt text.

The four types of resource which can have alt text when inserted as a figure are `image`, `video`, `audio` and `math`. Resources of type `code` and `table` do not support alt text, since they themselves are just text. If any alt text is provided for a code or table resource it is ignored.

Alt text is text which is intended to take the place of the resource if the resource itself cannot be seen. In the case of images, the obvious use case is for readers with visual disabilities who are using a screen reader, but it also includes audiobooks and ebook readers which often do not support embedded images, audio and video.

Here's an example of good alt text:

~~~
{alt: "a red apple, possibly a McIntosh or Spartan"}
![](fruit.jpg)
~~~

The alt text should **not** have the same content as the figure caption, if the figure caption is present. (Imagine the annoyance for someone with a visual disability having their screen reader read identical alt text and figure captions to them throughout an entire book!) Instead, the alt text should be descriptive of the image content, while the figure caption can be more creative. For example, a figure caption may be "Washington Crossing the Delaware" and the alt text could be "Denzel Washington riding a jet ski in a river". Having good alt text would enable readers who cannot see the image to still get the joke which the figure caption makes.

##### Figure Captions and Alt Text Together

These are some examples of figures with both alt text and a figure caption:

~~~
{alt: "Denzel Washington on a jet ski in a river"}
![Washington Crossing the Delaware](delaware.jpg)

{alt: "Denzel Washington on a jet ski in a river", caption: "Washington Crossing the Delaware"}
![](delaware.jpg)

{caption: "Earth From Space (Simplified)", alt: "a blue circle"}
```svg
<svg width="20" height="20">
  <circle cx="10" cy="10" r="9" fill="blue"/>
</svg>
```
~~~

##### The Figure Attribute List Takes Precedence

It is always an error to specify an attribute both in the attribute list for a figure and in the syntactic sugar locations, either after the backticks or in the square brackets.

However, if this is done, then the value in the attribute list takes precedence.

In the following figure, the format is `text` not `ruby`:

~~~
{format: text}
```ruby
puts "hello world"
```
~~~

In the following figure, the caption would be "Foo" not "bar":

~~~
{caption: Foo}
![bar](foo.png)
~~~

Again, both of these are not good Markua: attribute values should be specified only once.

#### Spans

There are three types of resources which can be inserted as spans:

1. Single-line inline code resources.
2. A `math` resource (regardless of location) without a caption.
3. An `image` resource without figure attributes, such as captions.

An inline code resource can be inserted as a span using the following syntax:

~~~
backtick `resource` backtick
~~~

An inline math resource of `latex` format can be inserted as a span using the following syntax:

~~~
backtick `resource`$ backtick + dollar sign
~~~

An inline math resource of `asciimath` format can be inserted as a span using the following syntax:

~~~
backtick `resource`@ backtick + at sign
~~~

The [code](#code) and [math](#math) resources are described more fully later.

##### Span Attribute Lists Can Be Used To Set The Format

When a resource is inserted as a span, the resource is inserted as part of the flow of text of a paragraph with no newlines before or after it. A span resource is intended to be extremely short and simple.

By default, the format of an inline resource is `text` for code. For math, you specify `latex` with a `$` (or with `{format: latexmath}`) and `asciimath` with an `@` (or with `{format: asciimath}`) after the closing backtick. For an image, it is determined by the file extension.

However, to support rare use cases, any span can have an attribute list. The attribute list on a span is specified immediately after the closing backtick. Span attribute lists can be used to set the format explicitly.

For example, this resource would be formatted as Ruby code:
~~~
Yada yada `puts "hi"`{format: ruby} yada yada.
~~~

This resource would be treated as LaTeX math:

~~~
Yada yada `some LaTeX math here`{format: latexmath} yada yada.
~~~

This is identical to using a `$`:

~~~
Yada yada `some LaTeX math here`$ yada yada.
~~~

This resource would be treated as AsciiMath:

~~~
Yada yada `some AsciiMath math here`{format: asciimath} yada yada.
~~~

This is identical to using an `@`:

~~~
Yada yada `some AsciiMath math here`@ yada yada.
~~~

This resource would be treated as MathML math:

~~~
Yada yada `some MathML math here`{format: mathml} yada yada.
~~~

Yes, you can actually insert a math resource of `mathml` format as a span (assuming you remove all newlines from your MathML), but it's so verbose that it's typically bad idea. You're much better off using AsciiMath or LaTeX math for spans.

Finally, if you wish to insert an image in the middle of a sentence, chances are you are trying to insert an emoji. You can do this with a span image, if you want exact control of what your emoji look like. However, note that emoji also have special support in Markua, described [here](#emoji).

##### Inserting Resources Into a Span Context

In Markua, resources can be inserted into a span context (within a paragraph or other block element) or into a block context (with blank lines above and below it).

Now, it doesn't make sense for many types of resources to be inserted into, say, the middle of a sentence. However, it does make sense for single-line math examples, for single-line code snippets, and for emoji.

So, the rules for inserting resources into a span context are as follows:

1. Any resource can be inserted into a span context, such as the middle of a paragraph.
2. Any resource with a caption which is inserted into a span context is treated as though there is a single newline before and after it, causing it to be inserted as a figure within the span context.
3. The following resource types, when they do not have a caption, can be inserted into a span context without causing single newlines to implicitly precede and follow them:
   a) a `image` without a caption, regardless of location or format
   b) a `math` resource, regardless of location or format
   c) a single-line inline `code` resource
4. All other resources cause single newlines to implicitly precede and follow them when being inserted into a span context.

In terms of inserting resources into a block context: all resource types and formats can be inserted into a block context, with and without captions.

If a resource is inserted in a span context, and it can fit in the span context, it is inserted as a span, with whitespace before and after it. Examples of resources which can fit in a span context are images without captions, video without captions (since an image is used as a placeholder), single-line code samples and single lines of poetry.  Now, there are certain types of resources which, when inserted into a span context, cause the addition of single newlines before and after the resource. These include any resource with a caption, any type of table, a multi-line code sample, any math example, and multi-line poetry.

If a local or web resource is inserted with no newlines before or after it, but there is a caption, the resource is treated as though there are single newlines before and after it. So the following two paragraphs are equivalent:

~~~
Here's some text ![Foo](bar.png) and more text.

Here's some text
![Foo](bar.png)
and more text.
~~~

In both cases, the `bar.png` image is inserted as a figure, and the text in the square brackets is the figure caption, not the alt text. The text in square brackets before a local or web resource is always the figure caption. Also, in both cases, the text which follows the figure is part of the same paragraph as the text which precedes the figure, unless there is a blank line after it to start a new paragraph. This is discussed further [here](#inserting-into-paras). Even though both images above are inserted as figures, in the first case there is no way to specify alt text. This is why the implicit newline approach is inferior to using explicit newlines, since with explicit newlines an attribute list can be defined on the figure like this:

~~~
Here's some text
{alt: "a shoal"}
![Foo](bar.png)
and more text.
~~~

Finally, note that this is all true for all local or web resources, regardless of resource type. The following two paragraphs which contain a web code resource are also equivalent:

~~~
Hello in Ruby is a simple ![Hello World in Ruby](http://markua.com/hello.rb) statement.

Hello in Ruby is a simple
![Hello World in Ruby](http://markua.com/hello.rb)
statement.
~~~

For the purpose of brevity, this point will not be explained in each section about different resource formats.

#### Resource Locations

A resource is either considered a local, web or inline resource based on its location:

Local Resource
: The resource is stored along with the manuscript--either in a `resources` directory on a local filesystem, or uploaded to the same web service where the Markua document is being written.

Web Resource
: The resource is referred to via an `http` or `https` URL.

Inline Resource
: The resource is defined right in the body of a Markua document.

##### Local Resources

If local resources are used, all local resources must be stored inside a `resources` directory, or one of its subdirectories. The `resources` directory is not part of the path to the resource.

Here's how the paths to local resources work:

1. An image called `foo.jpg` in the `resources` directory should be referred to as `![](foo.jpg)`, but can also be referred to as `![](resources/foo.jpg)`. Note that leading slashes are not allowed: `![](/foo.jpg)` and `![](/resources/foo.jpg)` are both illegal.
2. An image called `bar.png` in a subdirectory `images` of the `resources` directory should be referred to as `![](images/bar.png)`, but can also be referred to as `![](resources/images/foo.jpg)`. Note that leading slashes are not allowed: `![](images/bar.png)` and `![](resources/images/foo.jpg)` are both illegal.

Typically, there is only one way to do anything in Markua. The reason that there are two ways in this case is that there are, and always will be, more Markdown-aware tools in the world than Markua-aware tools. So, supporting relative paths is a must, and a relative path does include the `resources/` part of that path.

Nested directory trees work as well. A file called `foo.rb` in a `ch1/examples/ruby` directory tree inside the `resources` directory is referenced as `![](ch1/examples/ruby/foo.rb)` or as `![](resources/ch1/examples/ruby/foo.rb)`.

Note that you cannot navigate upward in paths with `../`. This would be a security hole, so it must be forbidden by a Markua Processor.

Markua does not specify whether there are any subdirectories of the `resources` directory, or what their names are. Since any subdirectories have their names as part of the path to the resource, authors can do whatever they want. For example, you can create subdirectories of the `resources` directory for different types of resource, such as `images`, `audio`, `video`, `code`, `math` and `tables`, but you can also just put them all in the `resources` directory together. Also, to be clear: the names of the directories have no meaning, and do not restrict the formats of what can go inside them.

The local resources approach can also be used by hosted services. Internally, services can store resources wherever they want, but if they provide a download (say as a zip file) they should create the resources directory and provide the uploaded resources in that directory. If a nested structure is used, it should be exported that way--if a web service produces paths which reference images inside an images directory (e.g. as `images/foo.png`), then the zip file containing an export should contain a `resources` directory which contains an `images` subdirectory with the images.

##### Web Resources

If web resources are supported, both `http:` and `https:` resources should be supported.

Web resources are identified by the absolute URL of the resource on the internet.

##### Inline Resources

Inline resources can be of type `code`, `math` (regardless of format), `table`, or an `image` resources of `svg` format. Since an SVG image is just XML text, it can be contained inline in the text of a Markua document. This is not something that is true for binary resources like PNG or JPEG images or any type of audio or video file--these can only be local or web resources.

{#resource-types-and-formats}
### Resource Types and Formats

There are seven types of resources: `audio`, `code`, `image`, `math`, `poetry`, `table` and `video`. Each type of resource has a number of supported formats. Any of the seven resource types can be inserted as a local resource or web resource, and many of the resource types can also be inserted as an inline resource.

Both the type and the format can be specified in an attribute list, by the respective `type` and `format` attributes.

The type and the format can also be inferred from the file extension and, in the case of web resources, the URL.

The following table shows the mapping of local file extensions to the default `format` and `type` inferred. Note that these are just defaults: a resource can be set to be any type and format using the attribute list, and this overrides what is inferred from the file extension.

{caption: "Formats Mapped to Local Resource Types", id: "resource-types-and-formats"}
| Extension    | `format`     | `type`   | Description         |
| :----------- | :----------: | :------: | ------------------- |
| `.aac`       | `aac`        | `audio`  | AAC audio           |
| `.m4a`       | `aac`        | `audio`  | AAC audio           |
| `.mp3`       | `mp3`        | `audio`  | MP3 audio           |
| `.oga`       | `ogg`        | `audio`  | Ogg Vorbis          |
| `.ogg`       | `ogg`        | `audio`  | Ogg Vorbis          |
| `.wav`       | `wav`        | `audio`  | WAV audio           |
| `.wave`      | `wav`        | `audio`  | WAV audio           |
| `.txt`       | `text`       | `code`   | Unformatted code    |
| (other)      | `guess`      | `code`   | Formatted code      |
| `.gif`       | `gif`        | `image`  | GIF image           |
| `.jpeg`      | `jpeg`       | `image`  | JPEG image          |
| `.jpg`       | `jpeg`       | `image`  | JPEG image          |
| `.png`       | `png`        | `image`  | PNG image           |
| `.svg`       | `svg`        | `image`  | SVG image           |
| `.svgz`      | `svgz`       | `image`  | Zipped SVG          |
| `.asciimath` | `asciimath`  | `math`   | AsciiMath math      |
| `.mathml`    | `mathml`     | `math`   | MathML math         |
| `.latexmath` | `latexmath`  | `math`   | LaTeX math          |
| `.tex`       | `latex`      | `code`   | LaTeX text          |
| `.poetry`    | `poetry`     | `poetry` | Poetry              |
| `.tbl`       | `table`      | `table`  | Markua table        |
| `.mp4`       | `mp4`        | `video`  | MP4 video           |
| `.webm`      | `webm`       | `video`  | WebM video          |

Note that these file extensions are case-insensitive. Also, note that .mp4 is used for MP4 video, not MP4 AAC audio.

Also, as discussed in the [code](#code) section, Markua Processors must interpret all unspecified file extensions as specifying a resource of type `code` with a format of `guess`, unless the resource is a web resource. If the type and format are not specified and the resource is a web resource, the Markua Processor may use the domain to decide what type of resource to assume. For example, a domain of `youtube.com` may be assumed to be of type `video`, a domain of `instagram.com` may be assumed to be of type `image`, and a domain of github.com may be assumed to be of type `code`.

If the type is not specified in the attribute list, the format determines the type. The formats can either be specified by the `format` attribute or (in most cases) inferred from the file extension for local and web resources. (Inline resources obviously have no file extension, since they are contained in the body of a Markua document.)

As an author, all you typically do is provide the correct file extension for a local resource or set the format in the attribute list. Markua recognizes the format, and uses it to determine the type. If the format is unrecognized, then the resource is treated as a resource of type `code` and with a format of `guess`.

It's important to emphasize that the type and format of a resource can be overridden using an attribute list. In rare instances, it is useful to override the `type` and `format` which have been inferred by the Markua Processor based on the file extension of the resource. This is done by specifying a type and/or format in the attribute list of the resource.

Three examples of when this could be desired are:

1. When writing about, say, the SVG file format, you may want to treat a `.svg` file as a resource of type `code` instead of type `image`. This way, the SVG image (which is just XML text) would be shown as code, instead of interpreted as an image. This would be accomplished by the attribute list `{type: code, format: text}`.
2. When writing about a programming language which is not identified correctly by a Markua Processor, you may want to force the format of the language.
3. When writing about LaTeX math, you may want to force the type to be `code` not `math`.

In the chapters ahead, we will consider each of the types of resources in more detail, as well as the various formats that they support. We will also discuss the supported attributes for each resource type. Resources have different default attributes based on their type, format and insertion method.

{#images}
### Images

The syntax to insert an image is the same compact and consistent syntax that is used for any resource. Local and web resource locations are supported for any type of image; inline resource locations are supported for SVG images only.

Per the [table](#resource-types-and-formats) of resource types and formats, the following types of images are supported in Markua: GIF, PNG, JPEG, SVG and zipped SVG.

Images are always inserted as figures.

We will discuss the supported and the default attributes for images, and then show examples of images being inserted for local, web and inline images.

Note that regardless of the image location, a Markua Processor can embed the image in the output format. For example, a web image does not need to be loaded from the web every time; it can be inlined in the output by the Markua Processor. A Markua Processor can also process images such that all images are placed on the web with URLs, and the images are loaded by the reader from the web.

Images have some of the only non-semantic formatting in Markua. Images can have `width`, `height`, and `align` or `float` attributes, or can be `fullbleed`. These settings, which also apply to the posters for videos, are so universal when applied to images that it would be too purist for Markua to insist that the only way to format images was to add a `class` element, and then style the `class` of the image elsewhere. Markua is semantic, but it's also pragmatic: by providing a few basic ways to format images, it enables authors to make in-progress books look good enough to publish in-progress.

#### Supported Attributes for Images

The following are the supported attributes for image resources, in addition to the `type`, `format`, `caption` and `class` attributes which all resources support:

`align`
: The `align` can be `left`, `right` or `middle`. The default is `middle`. Combined with `width` and `height`, this provides basic image formatting. When `align` is specified, text goes above and below the image, but the image and its surrounding whitespace occupies the entire width of the page. In terms of the specific values of `align`, a Markua Processor must interpret `left` as "on the left side of the page", `right` as "on the right side of the page" and `middle` as "in the middle of the content area of the page, respecting margins" in all cases. Finally, note that `inside` and `outside` are not supported for `align`. If you are using those attributes, chances are you should be floating the text around the image by using the `float` attribute, not the `align` attribute.

`alt`
: The `alt` is the alt text, to be displayed when the image cannot be shown. This is provided in the figure attribute list.

`cite`
: An image can have a citation. A Markua Processor is free to combine this citation with the caption attribute or display it separately.

`float`
: The `float` can be `left`, `right`, `inside` or `outside`. The `left` and `right` attribute values mean the same thing as they do with `align`. When `float` is specified, text flows around the image. It is an error to specify both `align` and `float`. Note that `middle` is not supported for `float`, since Markua is not a good choice for the types of advanced layouts which flow text on both sides of an image. For that, you should use something like InDesign; this is why Markua Processors such as Leanpub can export InDesign files. Also, note that `float` supports `inside` or `outside`, but `align` does not. What a Markua Processor does with `inside` and `outside` is more complex. A Markua Processor must interpret `inside` as "near the spine" and `outside` as "away from the spine" in a print book. In an ebook, however, a Markua Processor has some flexibility in terms of the meaning of `inside` and `outside`: it can either interpret `inside` as "left" or it can interpret `inside` as "left if the language is left-to-right, and right if the language is right-to-left". Similarly, a Markua Processor can either interpret `outside` as "right" or it can interpret `outside` as "right if the language is left-to-right, and left if the language is right-to-left". If that makes your head hurt, just use `left` and `right` instead.

`fullbleed`
: `true` or `false`. The default is `false`. If `true`, the Markua Processor should ensure that the image is the full size of the page, with no margins on the page. If `false`, the `width`, `height` and `align` attributes are used instead and margins are respected.

`height`
: The height of the image, in percentage of page content area height (respecting margins). This is specified as a number (integer or float) between 1 and 100 followed by a percentage sign (%). The quotes are optional. So, you can say `{height: "70%"}`, `{height: 70%}`, `{height: "70.5%"}` or `{height: 70.5%}`.

`url`
: An image can have a URL, which is the URL of the `cite` attribute if present, and the URL that the image itself links to, if the `cite` attribute is not present. A Markua Processor is free to combine this URL with the `cite` and `caption` attributes however it wishes, e.g. by linking the `cite` attribute text to the `url` or showing the `url` in parentheses or in a footnote. The use of the `url` attribute is discussed further below.

`width`
: The width of the image, in percentage of page content area width (respecting margins). This is specified as an number (integer or float) between 1 and 100 followed by a percentage sign (%). The quotes are optional. So, you can say `{width: "70%"}`, `{width: 70%}`, `{width: "70.5%"}` or `{width: 70.5%}`.

Note that if only one of `width` and `height` are specified, the Markua Processor should scale the image proportionally if possible (again, respecting margins). If both `width` and `height` are specified, the Markua Processor should scale the image accordingly, ignoring the aspect ratio. (So, it's almost always a bad idea to specify both `width` and `height`.)

#### Local Images

The following are some examples of local images:

~~~
Here's a paragraph before the first figure.

![A Piece of Cake](cake.jpg)

Here's a paragraph between the first and second figures.

{alt: "a slice of chocolate cake", fullbleed: true}
![A Piece of Cake](images/cake.jpg)

Here's a paragraph between the second and third figures.

{alt: "a slice of apple pie with ice cream on top", class: "food-closeup"}
![A Piece of Pie](pie.jpg)

Here's a paragraph after the third figure.
~~~

In the above example, the first and third images were directly in the `resources` directory, whereas the second image was in an `images` subdirectory of the `resources` directory.

#### Web Images

The following are some examples of web images:

~~~
Here's a paragraph before the first figure.

![A Piece of Cake](http://markua.com/cake.jpg)

Here's a paragraph between the first and second figures.

{alt: "a slice of chocolate cake", fullbleed: true}
![A Piece of Cake](http://markua.com/cake.jpg)

Here's a paragraph between the second and third figures.

{alt: "a slice of apple pie with ice cream on top", class: "food-closeup"}
![A Piece of Pie](http://markua.com/pie.jpg)

Here's a paragraph after the third figure.
~~~

#### Inline Images (SVG only)

SVG images are just XML text, so they can be inserted inline in Markua:

~~~
Here's a paragraph before the figure.

{caption: "Earth From Space (Simplified)", alt: "a blue circle"}
```svg
<svg width="20" height="20">
  <circle cx="10" cy="10" r="9" fill="blue"/>
</svg>
```

Here's a paragraph after the figure.
~~~

Note that when you are writing about SVG and want to display the SVG text, what you are really doing is creating a code resource. This is shown [later](#writing-about-svg).

#### Images, Attributes and Links

As discussed previously, images support `url`, `cite` and `alt` attributes. Images also support captions, like all resources inserted as figures.

As discussed previously, the exact question of what to do with `cite` and `url` attributes is dependent on the implementation of the Markua Processor. This can also vary based on context. The following examples will make this clear, using Leanpub as an example.

#### Setting the `url` Attribute

~~~
{url: "http://peterarmstrong.com/pictures/1.jpg"}
![](cake.jpg)
~~~

Here's what Leanpub will do with these attributes:

1. There is no caption.
2. The image itself will link to <https://peterarmstrong.com/pictures/1.jpg>.

#### Setting the `caption` and `url` Attributes

~~~
{url: "http://peterarmstrong.com/pictures/1.jpg"}
![A Piece of Cake](cake.jpg)
~~~

Here's what Leanpub will do with these attributes:

1. The caption is "A Piece of Cake" (no quotes).
2. The caption will link to <https://peterarmstrong.com/pictures/1.jpg>.
3. The image itself will link to <https://peterarmstrong.com/pictures/1.jpg>.

#### Setting the `caption` and `url` Attributes

~~~
{caption: "A Piece of Cake", url: "http://peterarmstrong.com/pictures/1.jpg"}
![](cake.jpg)
~~~

This is identical to the previous example. It doesn't matter which way the `caption` attribute is set; it's the same.

To be redundant, here's what Leanpub will do with these attributes:

1. The caption is "A Piece of Cake" (no quotes).
2. The caption will link to <https://peterarmstrong.com/pictures/1.jpg>.
3. The image itself will link to <https://peterarmstrong.com/pictures/1.jpg>.

#### Setting the `alt`, `caption` and `url` Attributes

~~~
{alt: "a slice of chocolate cake", url: "http://peterarmstrong.com/pictures/1.jpg"}
![A Piece of Cake](cake.jpg)
~~~

Here's what Leanpub will do with these attributes:

1. The caption is "A Piece of Cake" (no quotes).
2. The caption will link to <https://peterarmstrong.com/pictures/1.jpg>.
3. The image itself will link to <https://peterarmstrong.com/pictures/1.jpg>.
4. The text "a slice of chocolate cake" will be provided as alt text (for accessibility) in all output formats which support it.

#### Setting the `url`, `caption` and `alt` Text

~~~
{alt: "a slice of chocolate cake", cite: "Peter's Food Photography", url: "http://peterarmstrong.com/pictures/1.jpg"}
![A Piece of Cake](cake.jpg)
~~~

Here's what Leanpub will do with these attributes:

1. The caption will become "A Piece of Cake â€” Peter's Food Photography". Specifically, the caption text will be the value of the `caption` attribute, followed by a space, an em dash, a space, and the value of the `cite` attribute.
2. The "Peter's Food Photography" part will link to <https://peterarmstrong.com/pictures/1.jpg>.
3. The image itself will link to <https://peterarmstrong.com/pictures/1.jpg>.
4. The alt text will be provided as alt text in HTML output, for accessibility support.

#### Adding a Link Around an Image

Besides using `url` attributes to create links out of images, you can also use the Markua link syntax around an images itself. This is the standard Markdown link syntax which Markua inherited unchanged.

So, you can do the following:

~~~
[![A Piece of Cake](cake.jpg)](https://peterarmstrong.com/pictures/1.jpg)
~~~

Frankly, this syntax has enough line noise to remind me a bit of JWZ's "now you have two problems" [joke](https://blog.codinghorror.com/regular-expressions-now-you-have-two-problems/) about regular expressions.

What this is doing is inserting an image as a resource with a caption `![A Piece of Cake](cake.jpg)` and then wrapping the entire thing with a link. If you think of the image resource as `r`, this is just `[r](https://peterarmstrong.com/pictures/1.jpg)`. Simple!

Now, if you want to do this, you can. Chances are you'll only want to do this if you've been writing Markdown for years, or if you really hate attribute lists. If neither of those is true for you, you'll probably prefer to just use a `url` attribute.

Note that you can also use a span `url` attribute, if you are inserting an image inline:

~~~
Yada yada ![foo](bar.png){url:"http://leanpub.com"} yada yada.
~~~

Whether this is better or worse than the line noise version is a matter of taste:

~~~
Yada yada [![foo](bar.png)](http://leanpub.com) yada yada.
~~~

Now, if you combine both of them, the Markua processor should use the outer link, and log an error:

~~~
Yada yada [![foo](bar.png){url:"http://leanpub.com"}](http://markua.com) yada yada.
~~~

Here, this would link to `http://markua.com`, not `http://leanpub.com`, and the Markua Processor should log an error.

However, to be clear: never write Markua like this.

{#video}
### Video

The syntax to insert a video is the same compact and consistent syntax that is used for any resource. Local and web resource locations are supported for both video formats; inline resource locations for video are obviously not supported.

A Markua Processor may choose to not support video at all, or to only support one of local or web video due to bandwidth or copyright concerns.

Unlike images, which are supported in most circumstances, with video files it's currently a bit of a crapshoot. There's currently a dominant proprietary format (H.264, or .mp4) and a new open source challenger (WebM). It's entirely likely that many ebook readers won't support either.

Also, unlike images where many images will accompany the manuscript itself, with video it's expected that authors will be uploading their videos to sites such as YouTube first, and then reusing these videos in the contents of their Markua books. So, while video can be local or web video, web video will be much more prominent than web images in a Markua book.

Furthermore, unlike with web images where the format (and thus the type) are typically discoverable from the file extension in the URL, with web video it's usually not. So, for web videos, there will typically be a `{type: video}` attribute list at a minimum. That said, if the type and format are not specified and the resource is a web resource, the Markua Processor may use the domain to decide what type of resource to assume. So YouTube videos may just work in some Markua Processors, like Leanpub, without specifying either the `type` or `format`.

Per the [table](#resource-types-and-formats) of resource types and formats, the following types of videos are supported in Markua: MP4 and WebM.

We will discuss the supported and the default attributes for videos, and then show examples of videos being inserted for both local and web videos.

#### Supported Attributes for Video

The following are the supported attributes for video resources, in addition to the `type`, `format`, `caption` and `class` attributes which all resources support. Note that the `caption`, `class`, `fullbleed`, `height` and `width` attributes apply to the `poster` image for the video--not to the video itself during playback.

`align`
: The `align` can be `left`, `right` or `middle`. This applies to the `poster` image for the video, and works just like it does with images.

`embed`
: true or false. If true, then you can actually embed the video file or reference it and play it. If false, then it's from a site like YouTube which disallows this. In this case, this should function like a link to external web page, but open an appropriate app (e.g. the YouTube app) instead of a browser. A Markua Processor can be smart about defaults, and parse the URL to set the value of the `embed` attribute.

`float`
: The `float` can be `left`, `right`, `inside` or `outside`.  This applies to the `poster` image for the video, and works just like it does with images. It is an error to specify both `align` and `float`.

`fullbleed`
: `true` or `false`. The default is `false`.  This applies to the `poster` image for the video, and works just like it does with images.

`height`
: This applies to the `poster` image for the video, and works just like it does with images.

`poster`
: The `poster` is the URL or path to an image which should be shown instead of the video before the video is played. If a Markua Processor is outputting some format where it is known that video resources are not supported, it must choose the poster to use as a replacement for the video. Books are not just ebooks--books can also be printed on the fibers of trees that have been chopped down ("paper"), producing something called a "book". These "books", whether they are bound in a sturdy fashion ("hardcover books") or a flimsy fashion ("paperback books"), have one thing in common with respect to embedded video: they do not support it. Finally, if a Markua Processor is embedding a web video from a web video service (e.g. YouTube) which has a known algorithm for the location of the poster images for its videos, the Markua Processor may choose to use that poster image if a `poster` attribute is not explicitly specified. However, if a poster attribute is specified, then it must be used by the Markua Processor.

`poster-format`
: The format of the `poster` image, if it exists. If this attribute is not specified, the format of the `poster` is inferred from the `poster` image file extension. This attribute needs to exist only to support `poster` images which do not have file extensions.

`transcript`
: The URL or path to a transcript of the video, which should be shown or dictated to people who cannot view video. This helps people with visual disabilities view course material, and helps with ADA compliance. For example, what Leanpub does with a `transcript` is as follows: a URL is linked to in the caption (but in a way which does not affect the Table of Contents), and a path is assumed to be a path to a Markua file which is then used to produce a web page at a public URL, which then is also linked to in the caption in a way which does not affect the Table of Contents. With the Markua files for transcripts, Leanpub only supports certain resource types to be included in the transcript files themselves. Specifically, images, video, audio are not supported, but code, poetry, math and tables are supported. When Leanpub generates a transcript, the URLs are publicly accessible but obscure. Identical transcripts should not make duplicate transcript files on the web, and using a new UUID every time would violate this. However, not changing the transcript URL when its content changed could lead to bad outcomes. So, the URL of a transcript on the web should be scoped to the book and affected both by its filename and its content. What Leanpub does is: (filename minus extension minus period plus hyphen plus the SHA hash).html. Including the filename eliminates collisions if filenames are unique but the hashes are not.

`width`
: This applies to the `poster` image for the video, and works just like it does with images.

#### Local Video

~~~
Here's a paragraph before the figure.

![A Piece of Cake](cake-eating-contest.webm)

Here's a paragraph after the figure.
~~~

#### Web Video

~~~
Here's a paragraph before the figure.

{type: video, poster: "http://img.youtube.com/vi/VOCYL-FNbr0/mqdefault.jpg"}
![Introducing Markua](https://www.youtube.com/watch?t=105&v=VOCYL-FNbr0)

Here's a paragraph after the figure.
~~~

Ironically, it took me about a year after that talk was recorded to finally figure out what Markua was.

{#audio}
### Audio

Just as with video, the audio support in ebooks and on the web is more varied than for images. With audio, there are MP3, AAC, Ogg and WAV formats all in widespread use, and there are a number of other formats with supporters. It's entirely likely that many ebook readers won't support any of them.

A Markua Processor may choose to not support audio at all, or to only support one of local or web audio due to bandwidth or copyright concerns.

Per the [table](#resource-types-and-formats) of resource types and formats, the following types of audio resources are supported in Markua: MP3, AAC, WAV and Ogg Vorbis.

The syntax to insert an audio file is the same compact and consistent syntax that is used for any resource. Local and web resource locations are supported for both audio formats; inline resource locations for audio are obviously not supported.

We will discuss the supported and the default attributes for audio files, and then show examples of audio being inserted for both local and web audio files.

#### Supported Attributes for Audio

The following are the supported attributes for audio resources, in addition to the `type`, `format`, `caption` and `class` attributes which all resources support.

`transcript`
: The URL or path to a transcript of the audio, which should be shown to people who cannot hear audio. This helps people with auditory disabilities view course material, and helps with ADA compliance. Transcripts should be produced and handled in an identical way to `video` resources. For example, Leanpub does this. See the Video resource section above for more information.

#### Local Audio

~~~
The full version of the talk is here:

![Full Talk](talk.m4a)
~~~

#### Web Audio

~~~
The full version of the talk is here:

![Full Talk](http://markua.com/talk.m4a)
~~~

{#code}
### Code

Code can be a local, web or inline resource, just like any other resource, and the same resource syntax applies to code as to all other resources.

As discussed, code cannot have alt text. It's just text. If any alt text is provided for a code resource, it is ignored.

Markua specifies only one specific file extension to be associated with a type of `code`: the `.txt` extension, which is for the format of `text`. However, Markua Processors must interpret **all** unspecified file extensions as specifying a resource of type `code` with a format of `guess`.

Regardless of whether syntax highlighting is supported and the programming language is detected, all code must be formatted as `monospaced text` by Markua Processors.

The `text` format means to not do any syntax highlighting as well.

The `guess` format is a request for the Markua Processor to guess at the programming language based on the file extension and/or the syntax of the code itself. Then, if the detected language corresponds to a particular programming language which the Markua Processor recognizes, and if the Markua Processor supports syntax highlighting, then it can format the resource as nicely syntax-highlighted code. Syntax highlighting is entirely optional in Markua Processors. If a Markua Processor does not support syntax highlighting, and/or if it cannot detect a matching supported programming language, then it must format the code as though the format was `text`--i.e. to format it as unformatted monospaced text.

Besides the `text` and `guess` values of the format attribute, you can also specify the programming language by setting the format attribute to a specific programming language. This is more reliable than `guess`. Unlike other resource types, Markua does not specify the complete set of the values of the `format` attribute--there are so many programming languages in the world, and new ones are added so frequently, that doing so would be impractical.

However, while a complete set of the values of the `format` attribute is not specified, Markua does specify the `console` value of the `format` attribute to indicate console input. A Markua Processor should format console input as such. (For example, Leanpub uses the open source Pygments library for its code formatting, and Pygments handles `console` format correctly, so Leanpub gets this for free.)

The default value of the format attribute for code is complex:

1. For code which is inserted as a span (which is only supported with inline resources), the default format is `text`.
2. For code which is inserted as a figure which is inserted as an inline resource using three tildes, the default format is `text`.
3. For all other code, the default format is `guess`. This includes local and web resources inserted as figures, and code inserted as an inline figure using three backticks.

Note that the default format can be overridden by specifying it via an attribute list, or after the three backticks in syntactic sugar.

{#supported-attributes-for-code}
#### Supported Attributes for Code

The following are the supported attributes for code resources, in addition to the `type`, `format`, `caption` and `class` attributes which all resources support.

`line-numbers`
: This determines whether the code sample shows line numbers. Legal values are `true` or `false`. The default value is `false`. Any value other than `true` is interpreted as `false`.

`number-from`
: If line numbers are shown, this lets you override the starting number of the line numbers. The default value is `1`.

`crop-start`
: Sometimes it's desirable to only show part of a code resource defined in an external file as the code example. The `crop-start` and `crop-end` attributes let you accomplish this. The `crop-start` attribute defines the line which represents the first line included from the resource. For example, `{crop-start: 10, crop-end: 15, line-numbers: true, number-from: 10}` ensures that lines 10-15 are shown and are numbered as lines 10-15. The default value is 1, which is the first line of the file.

`crop-end`
: This attribute ends the range started with crop-start. The default value of crop-end is to be omitted, which is equivalent to specifying the last line of the file.

##### Default Value of the `format` attribute in Inline Code Samples

The default value of the `format` attribute for a code resource inserted as a figure varies based on context.

If the code resource is a local or web resource, it defaults to `guess`.

If the code resource is an inline resource, the default varies based on the delimiter, and whether the code is inserted as a span or as a block.

With three backticks the default format is `guess`, and with three tildes, the default format is `text`. This way, you can vary the default without having to type an attribute list: if you want the code language guessed at, use backticks; if you don't, use tildes. Of course, you can specify any attributes you wish with either delimiter, and specified attributes override default ones. The only reason there are different defaults are to make things easier to type. Programmers refer to such niceties as "syntactic sugar".

The default value of block code resources inserted with three backticks can be overridden from `guess` to some other value by setting by the `default-code-language` attribute on the entire Markua document. (This attribute has no effect on resources inserted with three tildes.) The default value of code span resources inserted as spans with single backticks can be overridden from the default value of `text` to some other value by setting the `default-code-span-language` on the entire Markua document.

#### Local Code Resources

Local code resources can be inserted as a figure. In all the following examples of figures, the text in the square brackets is the figure caption, like it is in all figures.

This first figure will be a type of code and a format of `guess`. A Markua Processor which associates `.rb` file extensions with Ruby code will treat this as Ruby code; a Markua Processor which has no association for `.rb` files will treat it as plain text:

~~~
Here's a paragraph before the figure.

![Hello World in Ruby](hello.rb)

Here's a paragraph after the figure.
~~~

That is equivalent to:

~~~
Here's a paragraph before the figure.

{format: guess}
![Hello World in Ruby](hello.rb)

Here's a paragraph after the figure.
~~~

If you don't want to take chances you can do this:

~~~
Here's a paragraph before the figure.

{format: ruby}
![Hello World in Ruby](hello.rb)

Here's a paragraph after the figure.
~~~

Note that the caption is optional in all figures:

~~~
Here's a paragraph before the figure.

![](hello.rb)

Here's a paragraph after the figure.
~~~

#### Web Code Resources

Web code resources function identically to how local code resources work, including the significance of file extensions. The only differences is that the files are on the web.

This will be a type of code and a format of `guess` since the file extension is not specified:

~~~
![Hello World in Ruby](http://markua.com/hello.rb)
~~~

That is equivalent to:

~~~
{format: guess}
![Hello World in Ruby](http://markua.com/hello.rb)
~~~

If you don't want to take chances you can do this:

~~~
{format: ruby}
![Hello World in Ruby](http://markua.com/hello.rb)
~~~

Note that in the above examples of figures, the text in the square brackets is the figure caption, like it is in all figures.

{#inline-code-resources}
#### Inline Code Resources

Inline code resources are the most flexible way to insert code. They are the only way to insert code as a span resource, and the most straightforward way to add short code examples as figures.

{#code-spans}
##### Code Spans

The format of an inline code resource inserted as a span is:

~~~
Yada yada `some code here` yada yada.
~~~

Since "inline code resource which is inserted as a span" is a mouthful, this is just called a code span.

It is an error for a code spans to contain newlines.

The format of code inserted as a span defaults to `text`. However, you can override this by attaching an attribute list to the end of a span.

In the following example, the first statement let the format of the code default to `text`, whereas the second statement specifies the format of the code as `ruby`:

~~~
Hello World in Ruby is a simple `puts "hello world"` statement.

Hello World in Ruby is a simple `puts "hello world"`{format: ruby} statement.
~~~

Note that there is no syntactic sugar for this, since I don't like this, and I want it to be as distasteful as possible. So, this is a sort of "syntactic salt". Syntax highlighting does not make much sense for code which is inserted in the middle of a sentence--there's just not enough code there for it to be worthwhile. However, in Markua, any span can have an attribute list attached to it (in order to add index entries, for example), so there is no reason to explicitly forbid specifying a format in the attribute list.

##### Figure

Inline code resources work great as figures.

This will be a type of code and a format of `guess` since three backticks are used and since the format is not specified:

~~~
Some paragraph.

```
puts "hello"
```

Some paragraph.
~~~

That is equivalent to:

~~~
Some paragraph.

```guess
puts "hello"
```

Some paragraph.
~~~

If you don't want to take chances you can do this to explicitly specify the format:

~~~
Some paragraph.

```ruby
puts "hello"
```

Some paragraph.
~~~

This Ruby code may be formatted as such if the Markua Processor understands `ruby`. If not, the `ruby` format will be ignored.

If you don't like syntactic sugar you can do:

~~~
Some paragraph.

{format: ruby}
```
puts "hello"
```

Some paragraph.
~~~

If you want a figure caption, you can add it to the attribute list with any of the above. For example:

~~~
Some paragraph.

{caption: "Hello World in Ruby"}
```ruby
puts "hello"
```

Some paragraph.
~~~

Finally, if you want the code to definitely not get syntax highlighted, you can force format to be `text` in one of two ways.

First, you can set it explicitly:

~~~
Some paragraph.

```text
puts "hello"
```

Some paragraph.
~~~

Second, you can use three tildes instead of three backticks, since the default with tildes is `text` not `guess`:

```
Some paragraph.

~~~
puts "hello"
~~~

Some paragraph.
```

As discussed previously, console input and output should be formatted as such by a Markua Processor:

~~~
```console
$ git init
Initialized empty Git repository in /path/to/repo
```
~~~

Finally, it's important to note that when you are writing about other inline formats, such as SVG or AsciiMath, what you are really doing is creating a code resource. This is shown in the sections below, which discuss SVG and AsciiMath, but this applies more broadly.

{#writing-about-svg}
##### Writing about SVG

If you want to write about the SVG format, and show the actual SVG source (instead of the image produced), it needs to be of a `format` of `code`, not `image`.

Now, you can just be lazy and not provide `format` or `type` attributes at all, since guessing when neither is present always produces a type of `code`.

```
<svg width="20" height="20">
  <circle cx="10" cy="10" r="9" fill="blue"/>
</svg>
```

However, you can also just specify both, either this way...

{type: code}
```svg
<svg width="20" height="20">
  <circle cx="10" cy="10" r="9" fill="blue"/>
</svg>
```

...or this way:

{type: code, format: svg}
```
<svg width="20" height="20">
  <circle cx="10" cy="10" r="9" fill="blue"/>
</svg>
```

Or you can just specify xml, since SVG is xml:

```xml
<svg width="20" height="20">
  <circle cx="10" cy="10" r="9" fill="blue"/>
</svg>
```

Or you can just specify text, if you don't want syntax highlighting:

```text
<svg width="20" height="20">
  <circle cx="10" cy="10" r="9" fill="blue"/>
</svg>
```

Heck, you can even use tildes to do that:

~~~
<svg width="20" height="20">
  <circle cx="10" cy="10" r="9" fill="blue"/>
</svg>
~~~

#### Marking Code as Added or Deleted

Markua supports marking code as added or deleted, which can be helpful if you are writing a computer programming book and want to indicate what code should be added or removed to a larger program.

The way to do this is to add special comment lines to your code.

The magic words are `markua-start-insert`, `markua-end-insert`, `markua-start-delete` and `markua-end-delete`. Any line containing one of those words will be removed completely by a Markua Processor before being inserted into the output.

The Markua Processor will then be able to determine which code is being deleted or inserted, and format it accordingly. The recommended way for a Markua Processor to do this is to make code which is being inserted get **`bolded`**, and to make code which is getting deleted to be put in ~~`strikethrough`~~.

Finally, while syntax highlighting is optional in a Markua Processor, if a Markua Processor does support syntax highlighting it is allowed for the Markua Processor to not do any syntax highlighting when there is the presence of any of any special `markua-*` comments. Syntax highlighting may make it harder to notice the added and removed code, if they are formatted with bold and strikethrough respectively.

#### Line Wrapping in Code Resources

Code resources should have newlines added by the author to ensure that automatic line wrapping is not relied upon. Markua Processors may wrap lines to ensure that all code is visible on a page, and *may* add continuation characters (like the backslash `\` character) in the output to indicate that a line has been automatically wrapped. However, adding a continuation character is not a requirement, nor is the choice of which continuation character is used.

{#poetry}
### Poetry

Poetry can be a local, web or inline resource, just like any other resource, and the same resource syntax applies to poetry as to all other resources.

Poetry can only be inserted as a figure. It cannot be inserted as a span resource, like code can.

Markua specifies only one specific file extension to be associated with a type of `poetry`: the `.text` extension, which is for the format of `poetry`.

{#supported-attributes-for-poetry}
#### Supported Attributes for Poetry

The following are the supported attributes for poetry resources, in addition to the `type`, `format`, `caption` and `class` attributes which all resources support.

`monospaced`
: `true` or `false`. The default is `false`, except for a special case with inline poetry resources, discussed below. If `true`, the Markua Processor must use a monospaced font to output the poetry. If false, the Markua Processor may use whatever font (proportional or monospaced) it is configured to use to output poetry.

Note that inside a poetry resource, Markua [text formatting](#text-formatting) still applies. You can't do arbitrary Markua stuff like headings, images and tables, but you can do the text formatting like bold, italic, strikethrough, etc. So, if you want to write poetry involving asterisks and underscores, use a code block.

{#spacing-poetry-and-newlines}
#### Spacing, Poetry and Newlines

Regardless of the value of the `monospaced` attribute, all whitespace inside a poetry resource is respected. This includes all spaces and newlines, regardless of whether they are leading, internal or trailing spaces, and regardless of the number of consecutive newlines.

Poetry resources should have newlines added by the author to ensure that automatic line wrapping is not relied upon.

Markua Processors may wrap lines to ensure that all poetry is visible on a page, and *may* add continuation characters (like the backslash `\` character) in the output to indicate that a line has been automatically wrapped by the Markua Processor.

Obviously, seeing a continuation character is in poetry is terrible, so the author should consider this a mistake that needs to be fixed by manually line wrapping.

#### Local Poetry Resources

Local poetry resources look like many other resources inserted as figures. The text in the square brackets is the figure caption, like it is in all figures.

~~~
Here's a Shakespearean sonnet:

![Sonnet 130](sonnet130.text)

Here's an E. E. Cummings poem:

{monospaced: true}
![I Will Be](iwillbe.text)
~~~

#### Web Poetry Resources

Web poetry resources function identically to how local poetry resources work, including the significance of file extensions. The only differences is that the files are on the web.

~~~
Here's a Shakespearean sonnet:

![Sonnet 130](http://markua.com/sonnet130.text)

Here's a paragraph after the figure.
~~~

{#inline-poetry-resources}
#### Inline Poetry Resources

With an inline poetry resource, the default value of the `monospaced` attribute for a poetry resource varies based on the delimiter used.

To insert a poetry resource inline, you use a `---` delimiter:

~~~
Some paragraph

---
Shall I compare thee to a summer's day
---

Another paragraph
~~~

By default, the value of the `monospaced` attribute of a poetry resource is false. However, regardless of the value of the `monospaced` attribute, all whitespace is respected in a poetry resource. So, you can indent the last two lines of a sonnet with tabs or spaces without requiring a monospaced font. (The whitespace is preserved, but it is using a proportional font, not a monospaced one.)

~~~
Some paragraph

---
I grant I never saw a goddess go;
My mistress when she walks treads on the ground.
    And yet, by heaven, I think my love as rare
    As any she belied with false compare.
---

Another paragraph
~~~

Now, if you want to add a caption to your poetry, you need to use an attribute list:

~~~
Some paragraph

{caption: "Sonnet 130"}
---
I grant I never saw a goddess go;
My mistress when she walks treads on the ground.
    And yet, by heaven, I think my love as rare
    As any she belied with false compare.
---

Another paragraph
~~~

If you want to set the value of `monospaced` to true and type typewriter poetry like ee cummings, you can do this by setting the `monospaced` attribute to `true`. Here's a pretend poem which wants a monospaced font:

~~~
Some paragraph

{caption: "Peter's Pretentious Poem", monospaced: true}
---
i
  am
      a        cat
            a        l a z y          cat

me   ow
---

Another paragraph
~~~

Just like that poem, however, attribute lists aren't very poetic! So, you can also indicate that a poem is monospaced by adding a `*` after the opening delimiter:

~~~
Some paragraph

---*
i
  am
      a        cat
            a        l a z y          cat

me   ow
---

Another paragraph
~~~

There is no `*` after the closing delimiter. (This is similar to how you can add `$` or `@` after the opening delimiter to specify the type of inline math resource.)

{#tables}
### Tables

Tables are important elements in many Markua documents. Tables are also resources, albeit with a special syntax when used as an inline resource.

Per the [table](#resource-types-and-formats) of resource types and formats, a Markua table in an external file (either as a local or web resource) will be interpreted as such if it has a file extension of `.tbl`, or if it has a `format` of table or `type` of table specified via an attribute list.

Tables are always inserted as figures. Note, however, that a Markua Processor should list tables as tables, not figures, if the book has a Table of Figures and Table of Tables.

The syntax to insert a table defined in an external file on the local filesystem is the same as the syntax to insert a local resource:

~~~
{type: table, optional: attribute_list}
![Optional Table Caption](table_path)
~~~

The `table_path` lists the path to the external file which defines the table.

To insert a table defined inline, you just insert it by typing the table in an appropriate syntax.

Markua supports two types of tables, simple tables and complex tables. Both simple tables and complex tables can be inserted inline, or as local or web resources. Both simple tables and complex tables have the same legal attributes.

#### Simple Tables

The following are the principles of simple tables in Markua:

1. Formatting never applies to anything above it.
2. Use the fewest formatting characters possible.
3. Prioritize ease of writing over ease of reading.
4. Use the fewest attributes possible.
5. Be able to left-, center- and right- align columns.
6. You can create a simple table even if you can't line anything up, say if you're using a variable-width font.

Simple tables in Markua are virtually identical to GitHub Flavored Markdown (GFM) tables, as specified [here](https://help.github.com/en/articles/organizing-information-with-tables).

The only difference between Markua simple tables and GFM tables is that in Markua simple tables you *must* start and end each the line with a pipe (`|`) character. In GFM, the starting and ending pipes are optional.

Markua simple tables are best specified first by examples, and then the rules. These examples are similar to those from GFM, since the goal was to be as close to GFM as possible, without the pipe issue.

Note that simple tables may leave an optional single-space gap between the separator hyphens and the pipes, for consistency with GFM. (With GFM, the examples all leave spaces, but it works both ways.)

The following is how you create a simple table in Markua, with the spaces:

~~~
{optional: attribute_list}
| Header A   | Header B   | Header C   |
| ---------- | ---------- | ---------- |
| Body A1    | Body B1    | Body C1    |
| Body A2    | Body B2    | Body C2    |
| Body A3    | Body B3    | Body C3    |
~~~

The following is how you create a simple table in Markua, without the spaces:

~~~
{optional: attribute_list}
| Header A   | Header B   | Header C   |
|------------|------------|------------|
| Body A1    | Body B1    | Body C1    |
| Body A2    | Body B2    | Body C2    |
| Body A3    | Body B3    | Body C3    |
~~~

You don't need `type: table` when the table is defined inline, of course, since it's clear.

Here are some examples of Markua simple tables...

##### Basic Markua Simple Table

The following is a simple table, which has been formatted to line up:

~~~
| Header 1  | Header 2  |
| --------- | --------- |
| Content 1 | Content 2 |
| Content 3 | Content 4 |
~~~

##### Nothing Needs To Line Up

The following is a simple table, which has not been formatted to line up:

~~~
| Header 1  | Header 2 |
| --- | --- |
| Content 1 | Content 2 |
| Content 3 | Content 4 Can be Different Length |
~~~

Note that you need at least three hyphens (`-`) in each header separator cell, just as in GFM.

##### Left, Middle and Right Alignment with Colons

To specify column alignment, you add a colons to the header separator row, just as in GFM. You  still need at least three hyphens per header separator cell, just as in GFM.

~~~
| Left | Middle  | Right |
| :--- |  :---:  |  ---: |
| a    | b       | c     |
| d    | e       | f     |
~~~

Note that the alignment of the cell content does not matter, and the cells do not need to line up. This can also be lazily or pathologically written, and it would be both correct and incomprehensible.

~~~
| Left | Middle | Right |
| :--- | :---: |---: |
| a | b | c |
|    d |              e |   f   |
~~~

##### Pipes in Markua Simple Tables vs. GFM Tables

The following is a table in GFM, but not in Markua:

~~~
header 1 | header 2
-------- | --------
content  | content
more     | and more
~~~

You might think that it's clear this is a table, and that GFM gets it right. For that case, you would be correct.

However, the following is a table in GFM:

~~~
foo | bar
~~~

Now, this case is a bit surprising. Having to write backslash-escape every `|` character is not an acceptable tradeoff, in my opinion.

(It is obviously not a simple table in Markua, since there are no leading or trailing pipes.)

Finally, the following two lines are also considered two tables in some Markdown parsers:

~~~
foo `|` bar

foo \| bar
~~~

Since Markua requires leading and trailing pipes on each line, these are obviously not Markua simple tables.

Because of the leading and trailing pipe requirement, the probability of accidentally creating a table in Markua is essentially zero.

#### Complex Tables

The following are the principles of complex tables in Markua:

1. Formatting never applies to anything above it.
2. Prioritize clarity and consistency over brevity.
3. Prioritize ease of reading over ease of writing.
4. Use the fewest attributes possible.
5. Be able to left-, center- and right- align both columns and individual cells.
6. Be able to support footers.
7. Be able to specify multi-line header, cell and footer content.
8. You must line everything up to create a complex table, so you must use a fixed-width font in your editor.

Because of these principles, anyone trying to write a complex table correctly should produce the same result.

Note that complex tables support individual alignment of each cell in the table, as well as of columns. Simple tables only support alignment of columns.

The following is how you create a complex table in Markua:

~~~
{optional: attribute_list}
|============|============|============|
| Header A   | Header B   | Header C   |
|============|============|============|
| Body A1    | Body B1    | Body C1    |
|------------|------------|------------|
| Body A2    | Body B2    | Body C2    |
|------------|------------|------------|
| Body A3    | Body B3    | Body C3    |
|============|============|============|
| Footer A   | Footer B   | Footer C   |
|============|============|============|
~~~

W> Unlike with simple tables, complex tables have the formatting hyphens or equals signs go all the way to the pipes (or, as you'll see later, to one character before if a colon is used to align the column or cell). They do not leave a single space gap between the formatting and the pipes.

You don't need `type: table` when the table is defined inline, of course, since it's clear.

##### Headers and Footers

The header is separated from the body cells by a section separator, i.e. a row of `=` signs and `|` characters. Every row of cells is separated by a row separator, i.e. a row of `-` signs and `|` characters. The `|` characters **MUST** line up and **MUST** start and end each line. The header and footer rows are both optional, of course.

The header and footer rows are both optional. The following are also legal tables...

A header row and three body rows:

~~~
|============|============|============|
| Header A   | Header B   | Header C   |
|============|============|============|
| Body A1    | Body B1    | Body C1    |
|------------|------------|------------|
| Body A2    | Body B2    | Body C2    |
|------------|------------|------------|
| Body A3    | Body B3    | Body C3    |
|============|============|============|
~~~

Just body rows:

~~~
|============|============|============|
| Body A1    | Body B1    | Body C1    |
|------------|------------|------------|
| Body A2    | Body B2    | Body C2    |
|------------|------------|------------|
| Body A3    | Body B3    | Body C3    |
|============|============|============|
~~~

Header, one body row, footer:

~~~
|============|============|============|
| Header A   | Header B   | Header C   |
|============|============|============|
| Body A1    | Body B1    | Body C1    |
|============|============|============|
| Footer A   | Footer B   | Footer C   |
|============|============|============|
~~~

No footer:

~~~
|============|============|============|
| Header A   | Header B   | Header C   |
|============|============|============|
| Body A1    | Body B1    | Body C1    |
|------------|------------|------------|
| Body A2    | Body B2    | Body C2    |
|------------|------------|------------|
| Body A3    | Body B3    | Body C3    |
|============|============|============|
~~~

No header:

~~~
|============|============|============|
| Body A1    | Body B1    | Body C1    |
|------------|------------|------------|
| Body A2    | Body B2    | Body C2    |
|------------|------------|------------|
| Body A3    | Body B3    | Body C3    |
|============|============|============|
| Footer A   | Footer B   | Footer C   |
|============|============|============|
~~~

If there are only two rows separated by a section separator, they are interpreted as a header and a body row:

~~~
|============|============|============|
| Header A   | Header B   | Header C   |
|============|============|============|
| Body A1    | Body B1    | Body C1    |
|============|============|============|
~~~

If there are only two rows separated by a row separator, they are just two body rows:

~~~
|============|============|============|
| Body A1    | Body B1    | Body C1    |
|------------|------------|------------|
| Body A2    | Body B2    | Body C2    |
|============|============|============|
~~~

If there is only one row, it is interpreted as a body row, not a header row:

~~~
|============|============|============|
| Body A1    | Body B1    | Body C1    |
|============|============|============|
~~~

Finally, headers and footers can have multiple rows in them. This won't be used that frequently, but it is fully supported:

~~~
|============|============|============|
| Header A1  | Header B1  | Header C1  |
|------------|------------|------------|
| Header A2  | Header B2  | Header C2  |
|------------|------------|------------|
| Header A3  | Header B3  | Header C3  |
|============|============|============|
| Body A1    | Body B1    | Body C1    |
|------------|------------|------------|
| Body A2    | Body B2    | Body C2    |
|------------|------------|------------|
| Body A3    | Body B3    | Body C3    |
|------------|------------|------------|
| Body A4    | Body B4    | Body C4    |
|============|============|============|
| Footer A1  | Footer B1  | Footer C1  |
|------------|------------|------------|
| Footer A2  | Footer B2  | Footer C2  |
|------------|------------|------------|
| Footer A3  | Footer B3  | Footer C3  |
|============|============|============|
~~~

You may initially think that typing row separators would be annoying. My recommended approach is to write the table first, and then copy and paste the row separators. If you get the column widths wrong, updating row separators is a headache, and you'll end up copying and pasting them anyway.

##### Column and Cell Alignment

You can also specify the left, center and right alignment of columns. This can be done separately for the header, for the body, and for the footer. Also, any individual table cell--except the first one in the header, body or footer--can override the column alignment of the header, body, and footer.

This is in keeping with the principles that formatting never applies to anything above it, and to use the fewest formatting characters possible.

The exact rules will be specified shortly, but it helps to start with a few examples.

This table has a left-aligned column with a header of Header A, a centered column with a header of Header B, and a right-aligned column with a header of Header C:

~~~
|:============|:============:|============:|
| Header A    | Header B     | Header C    |
|=============|==============|=============|
| Body A1     | Body B1      | Body C1     |
|-------------|--------------|-------------|
| Body A2     | Body B2      | Body C2     |
|-------------|--------------|-------------|
| Body A3     | Body B3      | Body C3     |
|=============|==============|=============|
| Footer A    | Footer B     | Footer C    |
|=============|==============|=============|
~~~

By default, all cells in the table header, body and footer are left-aligned.

So, the following table has left-aligned headers, but its body columns are left-, center-, and right-aligned respectively:

~~~
|=============|==============|=============|
| Header A    | Header B     | Header C    |
|:============|:============:|============:|
| Body A1     | Body B1      | Body C1     |
|-------------|--------------|-------------|
| Body A2     | Body B2      | Body C2     |
|-------------|--------------|-------------|
| Body A3     | Body B3      | Body C3     |
|=============|==============|=============|
| Footer A    | Footer B     | Footer C    |
|=============|==============|=============|
~~~

You can use different alignments for the header and the body of the table.

This table is just like the previous one, but it has left-aligned (Header A), centered (Header B) and right-aligned (Header C) header columns, with right-aligned, left-aligned and then centered body columns.

~~~
|:============|:============:|============:|
| Header A    | Header B     | Header C    |
|============:|:=============|:===========:|
| Body A1     | Body B1      | Body C1     |
|-------------|--------------|-------------|
| Body A2     | Body B2      | Body C2     |
|-------------|--------------|-------------|
| Body A3     | Body B3      | Body C3     |
|=============|==============|=============|
| Footer A    | Footer B     | Footer C    |
|=============|==============|=============|
~~~

You can also override the alignment of an individual cell. This table is just like the previous one, but its Body B2 cell is overridden to be centered not left-aligned:

~~~
|:============|:============:|============:|
| Header A    | Header B     | Header C    |
|============:|:=============|:===========:|
| Body A1     | Body B1      | Body C1     |
|-------------|:------------:|-------------|
| Body A2     | Body B2      | Body C2     |
|-------------|--------------|-------------|
| Body A3     | Body B3      | Body C3     |
|=============|==============|=============|
| Footer A    | Footer B     | Footer C    |
|=============|==============|=============|
~~~

Formatting a separator row (`====`) cascades downward. Header alignment cascades into the body and footer; body alignment cascades into the footer.

However, individual cell separator row (`----`) footing does NOT cascade downward. It overrides an individual cell only; it does not change the column alignment going forward. In the above table, Body B3 is left-aligned (like its body column) not centered (like Body B2).

This has the following consequence:

The cells in the first row of a table header, table body or table footer must have the same alignment as the header, body or footer column they are in. They are used to define the alignment, not override it. If you need other cells in the table header, body or footer to have different alignments, those must do the overriding.

So, if you want every other cell in a column to have a different alignment than the first non-header cell in that column, each of them must have the overridden alignment. This would not be true if alignment overrides cascaded downward, but that would confuse a lot more people than helping this small edge case.

Since the alignment is done on the separator row above the first body row, it even works to align a column with no header or footer. The following columns are also left-, center-, and right-aligned respectively:

~~~
|:===========|:==========:|===========:|
| Body A1    | Body B1    | Body C1    |
|------------|------------|------------|
| Body A2    | Body B2    | Body C2    |
|------------|------------|------------|
| Body A3    | Body B3    | Body C3    |
|============|============|============|
~~~

You can override alignments anywhere.

The following table has left-aligned (A), centered (B) and right-aligned (C) header and footer columns, with right-aligned (A), left-aligned (B) and then centered (C) body columns--and it also overrides Header B2 to be right-aligned, Body A2 to be centered and Footer C2 to be left-aligned:

~~~
|:===========|:==========:|===========:|
| Header A1  | Header B1  | Header C1  |
|------------|-----------:|------------|
| Header A2  | Header B2  | Header C2  |
|------------|------------|------------|
| Header A3  | Header B3  | Header C3  |
|===========:|:===========|:==========:|
| Body A1    | Body B1    | Body C1    |
|:----------:|------------|------------|
| Body A2    | Body B2    | Body C2    |
|------------|------------|------------|
| Body A3    | Body B3    | Body C3    |
|------------|------------|------------|
| Body A4    | Body B4    | Body C4    |
|:===========|:==========:|===========:|
| Footer A1  | Footer B1  | Footer C1  |
|------------|------------|:-----------|
| Footer A2  | Footer B2  | Footer C2  |
|------------|------------|------------|
| Footer A3  | Footer B3  | Footer C3  |
|============|============|============|
~~~

However, just because you can, doesn't mean that you should.

##### Multiple-line rows, row spans and column spans

You can have more than one row of content in cells, and there is no ambiguity since each row of cells is separated with a row of `-` signs and `|` characters:

~~~
|=============|==============|=============|
| Header A    | Header B     | Header C    |
|:============|:============:|============:|
| Body A1     | Body B1      | Body C1     |
| is really   | is here      |             |
| really      |              |             |
| long        |              |             |
|-------------|--------------|-------------|
| Body A2     | Body B2      | Body C2     |
|-------------|--------------|-------------|
| Body A3     | Body B3      | Body C3     |
|=============|==============|=============|
| Footer A    | Footer B     | Footer C    |
|=============|==============|=============|
~~~

You can specify a column span just by skipping a `|` in the appropriate place:

~~~
|=============|==============|=============|
| Header A    | Header B     | Header C    |
|:============|:============:|============:|
| Body A1 and B1 Merged      | Body C1     |
|-------------|--------------|-------------|
| Body A2     | Body B2      | Body C2     |
|-------------|--------------|-------------|
| Body A3     | Body B3      | Body C3     |
|=============|==============|=============|
| Footer A    | Footer B     | Footer C    |
|=============|==============|=============|
~~~

Note that the alignment of the cell in the merged columns is that of its leftmost column, if no override is done. So, in the above table, Body A1 and B1 Merged is left-aligned not centered.

Now, if you want to override the alignment on a merged cell, you do that in the leftmost cell. So, in the below table, Body A2 and B2 Merged is centered not left-aligned.

~~~
|=============|==============|=============|
| Header A    | Header B     | Header C    |
|:============|:============:|============:|
| Body A1     | Body B1      | Body C1     |
|:-----------:|--------------|-------------|
| Body A2 and B2 Merged      | Body C2     |
|-------------|--------------|-------------|
| Body A3     | Body B3      | Body C3     |
|=============|==============|=============|
| Footer A    | Footer B     | Footer C    |
|=============|==============|=============|
~~~

You can specify a row span just by skipping a part-row of `-` signs in the appropriate place:

~~~
|=============|==============|=============|
| Header A    | Header B     | Header C    |
|:============|:============:|============:|
| Body A1     | Body B1      | Body C1     |
| and A2      |--------------|-------------|
| Merged      | Body B2      | Body C2     |
|-------------|--------------|-------------|
| Body A3     | Body B3      | Body C3     |
|=============|==============|=============|
| Footer A    | Footer B     | Footer C    |
|=============|==============|=============|
~~~

You can also individually align cells with colons in the `-` part-row **above** them. This alignment overrides any alignment already on the column, and it works for merged cells too:

~~~
|=============|===============|=============|
| Header A    | Header B      | Header C    |
|:============|:=============:|============:|
| Body A1 and B1 Merged       | Body C1     |
|------------:|:--------------|-------------|
| Body A2     | Body B2       | Body C2     |
|:-----------:| and B3 Merged |-------------|
| Body A3     |               | Body C3     |
|=============|===============|=============|
| Footer A    | Footer B      | Footer C    |
|=============|===============|=============|
~~~

In that table, column A is left-aligned, column B is centered and column C is right-aligned. However, cell A2 is right-aligned, cell A3 is centered and merged cell B2 and B3 is left-aligned.

{#table-attributes}
#### Supported Attributes for Tables

The following attributes apply to both simple tables and complex tables.

If there are any errors with the supported attributes for tables, such as the `column-widths` not adding up correctly or missing `%` signs, the Markua Processor must log an error or warning, and just output the table with either the erroneous attribute not set or with none of the attributes set.

The following is the supported attribute for table resources, in addition to the `type`, `format`, `caption` and `class` attributes which all resources support:

`column-widths`
: The column widths as a comma-separated list of numbers (integers and/or floats) and/or `*` symbols, from left to right, as a percentage of the total table width. In this attribute value, * means for the column to use the remaining space, equally divided between it and any other column with the * attribute. Examples: `{column-widths: "10%,30%,*,10%"}`, `{column-widths: "10%,*,40%,*"}`, `{column-widths: "10%, 30%, *, 12.5%"}`, `{column-widths: "95%, *, *"}`. The numbers used for the column-widths percentages must sum to exactly 100 (if only numbers are used), or to less than 100 (if there are any `*`s used). Every specified value must be at least 1, and every `*` must compute to at least 1. The number of values (numbers or `*`s) must match the number of columns. Like with the `width` attribute, the percentage sign (%) is required, to make it absolutely clear that these are not measurements in pixels or points. Finally, the list may contain optional whitespace before and/or after each comma.

`style`
: The style of the table. Values can be `simple`, `grid` or any other value. All Markua Processors must support values of `simple` and `grid` for tables. The default is `simple`. A Markua Processor may use whatever formatting it wants with `simple`, but it should be clear which cells are part of the table header, body and footer. A Markua Processor may also use whatever formatting it wants with `grid`, but it must show grid lines around each table cell. If a Markua Processor does not recognize the value of the `style`, it must format it as `simple` and log an error.

`width`
: The width of the table, in percentage of page content area width (respecting margins). This is specified as a number (integer or float) between 1 and 100 followed by a percentage sign (%). The quotes are optional. So, you can say `{width: "70%"}`, `{width: 70%}`, `{width: "70.5%"}` or `{width: 70.5%}`.

A Markua Processor may do whatever it wants when outputting a table. For example, a Markua Processor may choose to transform the table into an image, for maximum ebook reader compatibility--but at the expense of accessibility support in newer ebook readers.

{#math}
### Math

Math can be a local, web or inline resource, just like any other resource, and the same resource syntax applies to code as to all other resources.

Per the [table](#resource-types-and-formats) of resource types and formats, the following types of math resources can be supported by Markua Processors: LaTeX math or MathML.

Note that Markua processors do not need to support either math markup syntax (LaTeX math or MathML). If a Markua Processor does not support a math markup syntax, it should simply render the text of the math resource as unformatted monospaced text, much like a code resource of format `text`.

#### Supported Attributes for Math

The following is the supported attribute for math resources, in addition to the `type`, `format`, `caption` and `class` attributes which all resources support:

`alt`
: The `alt` is the alt text, to be displayed when the mathematical equations cannot be shown. The default alt text for math is "math". This can be provided in the figure attribute list. This is primarily intended for Markua Processors that output math as images; there are no output requirements for the alt text. This attribute functions as it does for images. (In fact, a Markua Processor may choose to transform the math into an image, for maximum ebook reader compatibility.)

Note that for math, the `format` is the name of the syntax used to write the mathematical equations. There are two special types of `format` for math baked into Markua: `latex` for LaTeX math and `mathml` for MathML math.

#### Local Math Resources

Local math resources can be inserted as a figure. In all the following examples of figures, the text in the square brackets is the figure caption, like it is in all figures.

~~~
Here's a paragraph before the figure.

{alt: "too large to fit in the alt text"}
![Proof of Fermat's Last Theorem](fermat-proof.mathml)

Here's a paragraph after the figure.
~~~

#### Web Math Resources

This is identical to how local math resources work, including the significance of file extensions. The only difference is that the files are on the web.

~~~
Here's a paragraph before the figure.

{alt: "too large to fit in the alt text"}
![Proof of Fermat's Last Theorem](http://markua.com/fermat-proof.tex)

Here's a paragraph after the figure.
~~~

Note that in the above examples of figures, the text in the square brackets is the figure caption, like it is in all figures.

#### Inline Math Resources

Inline math resources are the most flexible way to insert math. They are the only way to insert math as a span resource, and the most straightforward way to add short math examples as figures. LaTeX math, AsciiMath and MathML can be inserted inline as a span or figure.

##### Span

Being able to insert a math resource as a span is important, as it lets you write things like one of the kinematic equations `d = v_i t + \frac{1}{2} a t^2`$ inside sentences. This can be done with LaTeX math, AsciiMath, or (in theory) MathML.

To insert math as inline math, use a `$` after closing backtick for LaTeX math, an `@` after the closing backtick for AsciiMath, or an attribute list specifying a `format` of `latex`, `asciimath` or `mathml`. If none of these is done, the content of the backticks is treated as code and is output verbatim as monospaced text.

###### LaTeX math

There is syntactic sugar for LaTeX math which is inserted as a span, using the `$` character after the closing backtick:

~~~
Here's one of the kinematic equations `d = v_i t + \frac{1}{2} a t^2`$ inside a sentence.
~~~

The `$` character indicates the inline resource is LaTeX math.

If you don't like syntactic sugar, you can also use {format: latexmath} after the inline span resource:

~~~
Here's one of the kinematic equations `d = v_i t + \frac{1}{2} a t^2`{format: latexmath} inside a sentence.
~~~

###### AsciiMath

[AsciiMath](http://asciimath.org/) is a way of producing simple MathML equations, using about 1% of the typing. It's more terse than LaTeX math.

There is syntactic sugar for AsciiMath which is inserted as a span, using the `@` character after the closing backtick:

~~~
Here's one of the kinematic equations `d = v_i t + 1/2 at^2`@ inside a sentence.
~~~

The `@` character indicates the inline resource is AsciiMath.

If you don't like syntactic sugar, you can also use {format: asciimath} after the inline span resource:

~~~
Here's one of the kinematic equations `d = v_i t + 1/2 at^2`{format: asciimath} inside a sentence.
~~~

###### MathML

Technically you can insert MathML as an inline span resource, as long as you remove all the newlines. There is no syntactic sugar for this, since it is almost always a bad idea:

~~~
Yada yada `<some><mathml><here></here></mathml></some>`{format: mathml} yada yada.
~~~

No, that's not really MathML syntax. For an example of some, see this [Wikipedia page](https://en.wikipedia.org/wiki/MathML).

While it would almost always be a bad idea to insert MathML as a span resource, it would also be a bad idea to forbid it in the Markua spec.

If you're going to insert MathML, it should be inserted as a figure, with newlines used inside the MathML to format it in a somewhat readable way.

##### Figure

Both LaTeX math, AsciiMath and MathML can be inserted inline as a figure.

* LaTeX math can be inserted by specifying either `latex` or `$` after three backticks, or by specifying an attribute list of `{format: latexmath}`.
* AsciiMath can be inserted by specifying either `asciimath` or `@` after three backticks, or by specifying an attribute list of `{format: asciimath}`.
* MathML math can be inserted by specifying `mathml` after three backticks, or by specifying an attribute list of `{format: mathml}`.

All three let you produce mathematical equations like this:

```$
\left|\sum_{i=1}^n a_ib_i\right|
\le
\left(\sum_{i=1}^n a_i^2\right)^{1/2}
\left(\sum_{i=1}^n b_i^2\right)^{1/2}
```

###### LaTeX math

Here's how you do this using LaTeX math...

Here's the version with the syntactic sugar for the format after the backticks:

~~~
Here's a paragraph before the figure.

```$
\left|\sum_{i=1}^n a_ib_i\right|
\le
\left(\sum_{i=1}^n a_i^2\right)^{1/2}
\left(\sum_{i=1}^n b_i^2\right)^{1/2}
```

Here's a paragraph after the figure.
~~~

Here's the same thing, with the full format after the backticks:

~~~
Here's a paragraph before the figure.

```latexmath
\left|\sum_{i=1}^n a_ib_i\right|
\le
\left(\sum_{i=1}^n a_i^2\right)^{1/2}
\left(\sum_{i=1}^n b_i^2\right)^{1/2}
```

Here's a paragraph after the figure.
~~~

Here's the same thing again, with a full attribute list:

~~~
Here's a paragraph before the figure.

{format: latexmath}
```
\left|\sum_{i=1}^n a_ib_i\right|
\le
\left(\sum_{i=1}^n a_i^2\right)^{1/2}
\left(\sum_{i=1}^n b_i^2\right)^{1/2}
```

Here's a paragraph after the figure.
~~~

###### AsciiMath

Here's how you do this using AsciiMath...

Here's the version with the syntactic sugar for the format after the backticks:

~~~
Here's a paragraph before the figure.

```@
abs(sum_(i=1)^n a_i b_i) <= (sum_(i=1)^n a_i^2)^(1/2) (sum_(i=1)^n b_i^2)^(1/2)
```

Here's a paragraph after the figure.
~~~

Here's the same thing, with the full format after the backticks:

~~~
Here's a paragraph before the figure.

```asciimath
abs(sum_(i=1)^n a_i b_i) <= (sum_(i=1)^n a_i^2)^(1/2) (sum_(i=1)^n b_i^2)^(1/2)
```

Here's a paragraph after the figure.
~~~

Here's the same thing again, with a full attribute list:

~~~
Here's a paragraph before the figure.

{format: asciimath}
```
abs(sum_(i=1)^n a_i b_i) <= (sum_(i=1)^n a_i^2)^(1/2) (sum_(i=1)^n b_i^2)^(1/2)
```

Here's a paragraph after the figure.
~~~

If you wonder why I'm a fan of AsciiMath: I actually got that right on the first try at the [AsciiMath website](http://asciimath.org/).

Note that when you are writing about AsciiMath and want to display the AsciiMath text, what you are really doing is creating a code resource. This is essentially identical to what was shown earlier in writing about SVG images. It's also shown below.

{#writing-about-asciimath}
####### Writing about AsciiMath

If you want to write about AsciiMath, and show the actual AsciiMath code (instead of the formatted output), it needs to be of a `format` of `code`, not `math`.

Now, you can just be lazy and not provide `format` or `type` attributes at all, since guessing when neither is present always produces a type of `code`.

```
abs(sum_(i=1)^n a_i b_i) <= (sum_(i=1)^n a_i^2)^(1/2) (sum_(i=1)^n b_i^2)^(1/2)
```

However, you can also just specify both, either this way...

{type: code}
```asciimath
abs(sum_(i=1)^n a_i b_i) <= (sum_(i=1)^n a_i^2)^(1/2) (sum_(i=1)^n b_i^2)^(1/2)
```

...or this way:

{type: code, format: asciimath}
```
abs(sum_(i=1)^n a_i b_i) <= (sum_(i=1)^n a_i^2)^(1/2) (sum_(i=1)^n b_i^2)^(1/2)
```

Or you can just specify text:

```text
abs(sum_(i=1)^n a_i b_i) <= (sum_(i=1)^n a_i^2)^(1/2) (sum_(i=1)^n b_i^2)^(1/2)
```

Heck, you can even use tildes:

~~~
abs(sum_(i=1)^n a_i b_i) <= (sum_(i=1)^n a_i^2)^(1/2) (sum_(i=1)^n b_i^2)^(1/2)
~~~

###### MathML

There is no syntactic sugar for MathML.

Here's the MathML version, with the full format after the backticks:

~~~
Here's a paragraph before the figure.

```mathml
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mstyle displaystyle="true">
    <mrow>
      <mo>|</mo>
      <mrow>
        <mrow>
          <munderover>
            <mo>&#x2211;</mo>
            <mrow>
              <mi>i</mi>
              <mo>=</mo>
              <mn>1</mn>
            </mrow>
            <mi>n</mi>
          </munderover>
        </mrow>
        <msub>
          <mi>a</mi>
          <mi>i</mi>
        </msub>
        <msub>
          <mi>b</mi>
          <mi>i</mi>
        </msub>
      </mrow>
      <mo>|</mo>
    </mrow>
    <mo>&#x2264;</mo>
    <msup>
      <mrow>
        <mo>(</mo>
        <mrow>
          <munderover>
            <mo>&#x2211;</mo>
            <mrow>
              <mi>i</mi>
              <mo>=</mo>
              <mn>1</mn>
            </mrow>
            <mi>n</mi>
          </munderover>
        </mrow>
        <mrow>
          <msubsup>
            <mi>a</mi>
            <mi>i</mi>
            <mn>2</mn>
          </msubsup>
        </mrow>
        <mo>)</mo>
      </mrow>
      <mrow>
        <mfrac>
          <mn>1</mn>
          <mn>2</mn>
        </mfrac>
      </mrow>
    </msup>
    <msup>
      <mrow>
        <mo>(</mo>
        <mrow>
          <munderover>
            <mo>&#x2211;</mo>
            <mrow>
              <mi>i</mi>
              <mo>=</mo>
              <mn>1</mn>
            </mrow>
            <mi>n</mi>
          </munderover>
        </mrow>
        <mrow>
          <msubsup>
            <mi>b</mi>
            <mi>i</mi>
            <mn>2</mn>
          </msubsup>
        </mrow>
        <mo>)</mo>
      </mrow>
      <mrow>
        <mfrac>
          <mn>1</mn>
          <mn>2</mn>
        </mfrac>
      </mrow>
    </msup>
  </mstyle>
</math>
```

Here's a paragraph after the figure.
~~~

In case you're wondering: no, I didn't type this in. Instead, I did this:

1. I wrote the AsciiMath in the previous section, i.e. `abs(sum_(i=1)^n a_i b_i) <= (sum_(i=1)^n a_i^2)^(1/2) (sum_(i=1)^n b_i^2)^(1/2)`.
2. I went to the [AsciiMath](http://asciimath.org/) website and pasted it in the Input field.
3. I chose Show Math As > MathML Code for the Rendering field.

MathML is excellent as an output format for AsciiMath.

Here's the same thing again, with a full attribute list:

~~~
Here's a paragraph before the figure.

{format: mathml}
```
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mstyle displaystyle="true">
    (...identical code omitted for brevity...)
  </mstyle>
</math>
```

Here's a paragraph after the figure.
~~~

{#whitespace}
# Whitespace: Spaces, Tabs and Newlines

The goal for the handling of normal whitespace (spaces, tabs and newlines) in Markua is for everything to just work.

Note that these decisions about normal whitespace handling are decisions about prose, not poetry. Poetry has its own rules, and in poetry, all whitespace is preserved unchanged. The way this is accomplished is that poetry, whether in an external file or in the body of a Markua document itself, is handled as a [poetry resource](#poetry).

For prose, Markua has four principles of whitespace handling:

1. You should be able to look at a Markua document and know what is produced. Invisible formatting is frowned upon.
2. Paragraphs and sentences should be handled consistently, regardless of indentation and spaces after periods.
3. Manual whitespace formatting should be discouraged.
4. Newlines are newlines; spaces are spaces. These are different things.

These simple goals have far-reaching consequences:

1. Whitespace at the end of a line or file is ignored.
2. It doesn't matter how many spaces you add after a sentence.
3. All consecutive blank lines after the first blank line are ignored when separating paragraphs, and all consecutive blank lines after the second blank line are ignored when separating lists.
4. You can't manually wrap text with newlines being used as though they are spaces, but you can add a forced line break just by hitting the Enter key.

## Newlines

{#single-newlines}
### Single Newline = Forced Line Break

In Markua, a forced line break in the input is a forced line break in all output formats. This is true for paragraphs, lists, blockquotes, asides and blurbs.

In ancient history, some text editors did not automatically wrap lines of text, so manual wrapping of plain text files was a good thing to do. Also, for computer programmers, we still do not wrap our text when programming. However, for writing, automatic wrapping of paragraphs is essential for staying in the flow while writing, and for being able to edit your text without needing to re-wrap every line in a paragraph. This is one decision that even Microsoft Word gets right.

The handling of single newlines is the largest difference between Markua and Markdown. To learn more, see the newlines [discussion](#markdown-newlines) in the Differences with Markdown chapter.

The following is an example of Markua's single newlines:

~~~
I'm paragraph one. Yay!

This is paragraph two.
This is *still* in paragraph two, preceded by a forced line break.
This is also in paragraph two, also preceded by a forced line break.

This is paragraph three.
~~~

### Two or More Newlines = One Blank Line

Two or more consecutive newlines produce exactly one blank line, which separates block elements like paragraphs from each other. So, there is no reason to use more than two consecutive newlines.

When writing prose, there's basically no reason to add multiple blank lines. Worse, the most popular reason is a bad one: to attempt to manually accomplish a page break, or to make something look like a section break. However, Markua has special syntax for [scene breaks](#scene-breaks) and [page breaks](#page-breaks), which should be used for these purposes.

There's also a horrible hack to force whitespace, which works both to add spaces or blank lines. This is discussed [later](#whitespace-hack).

## Spaces and Tabs

### Spaces and Tabs at the Beginning of a Line are Only to Determine List Containment, and Extra Spaces are Removed

Spaces and tabs at the beginning of a line are only used to determine whether the content is contained in a list item--or, in the case of a nested list, which list the list item is contained in.

Besides this, in a paragraph, any manual indentation (using spaces or tabs at the beginning of a line) is just removed. This is even true after a forced line break, using a single newline.

So, if you're writing a sonnet, you can't manually indent the last two lines just by hitting Enter and adding two spaces at the beginning of the line. Instead, you need to use a [poetry resource](#poetry). To do this, you start a poetry resource with `___` or `---`. This will have the added benefit of allowing your poetry to be formatted using special font sizes and margins, to be more poetic than prose.

### Spaces and Tabs at the End of a Line are Removed

Unlike Markdown, all trailing spaces at the end of a line are ignored by Markua. This way, there is no [reliance on invisible formatting to produce newlines](#single-newlines), and editors which strip trailing spaces have no effect on a Markua document.

### Consecutive Spaces are Collapsed to One Space

Multiple internal spaces in the middle of a paragraph are all collapsed to one space. The following paragraphs are the same:

~~~
This is foo. This is bar.

This is foo.  This is bar.

This  is  foo.    This is      bar.
~~~

### A Markua Processor may Separate Sentences with Custom Whitespace

A Markua Processor may choose to detect what the end of a sentence is, and output a custom amount of whitespace between sentences within a paragraph. Regardless of whether this is one space, one and a half spaces, two spaces, or some other amount of space, the amount of chosen to separate sentences within paragraphs must be identical. (Yes, one and a half spaces at the end of a sentence is a real choice to output, and it is arguably better than one or two spaces. However, good luck trying to type it!)

This can be accomplished by a Markua Processor in two ways:

1. Don't even try to determine what a sentence is, and always output one space after periods.
2. Determine what a sentence is, and output a custom amount of space after it.

Either way, the amount of space after the end of a sentence must be the same for all sentences, regardless of how many spaces the author(s) typed. This way, multiple authors can collaborate on a Markua document and it will look consistent in the output, even if some authors use one space after sentences and other authors use two spaces after sentences.

Finally, note that determining the end of a sentence would be easier if all authors typed two spaces at the end of their sentences! This way, a Markua Processor could easily determine that something like "Mr. Armstrong" did not, in fact, contain the end of a sentence between `Mr.` and `Armstrong`.

{#lists}
# Lists

Markua supports two types of lists, bulleted lists and numbered lists, which can be formatted as either simple or complex lists.

The basics of bulleted and numbered lists are discussed first. This is followed by a discussion of simple and complex lists, which will contain examples of both.

Note that Markua distinguishes between "bulleted" and "numbered" lists, not between "unordered" and "ordered" lists (as is done by HTML and Markdown), since all lists have an order--otherwise they wouldn't be lists!

{#bulleted-lists}
## Bulleted Lists

Markua lets you make a bulleted list by starting each list item with either an asterisk (`*`) or a hyphen (`-`), followed by one space, followed by text content. You can't mix and match asterisks and hyphens in the same list.

You can build a bulleted list out of items starting with an asterisk and one space:

~~~
* foo
* bar
* baz
~~~

You can build a bulleted list out of items starting with a hyphen and one space:

~~~
- one
- two
- three
~~~

Markua could have supported just one of the asterisk or the hyphen, but this would have been too prescriptive.

To make a bulleted list in Markua:

* Start each list item with either an asterisk (`*`) or a hyphen (`-`).
* You can't mix and match asterisks and hyphens in the same list.
* Only one space is allowed after each bullet. Just as with headings, there is no reason to support any other number of spaces, and the increased consistency is a benefit.
* A single-element bulleted list is a list: although it is a pretty stupid list, treating it as a literal paragraph starting with an asterisk or hyphen would be even stupider.

In terms of style guidance, the preferred bullet type in Markua is the asterisk.

{#numbered-lists}
## Numbered Lists

In Markua, a numbered list can vary the following:

1. Numbering system
2. Numbering direction (ascending or descending)
3. Initial number (or letter, or Roman numeral)
4. Period or parentheses after the number (or letter, or Roman numeral)

The following choices of numbering system are supported:

1. Decimal numbers
2. Uppercase letters
3. Lowercase letters
4. Uppercase Roman numerals
5. Lowercase Roman numerals

Unlike in Markdown, in Markua the number that begins the list in the manuscript is the *same* number that begins the list in the output.

To make a numbered list in Markua:

* Start two or more consecutive lines with either a consecutive (e.g. `1.`, `2.`, `3.`) or the first (e.g. `1.`, `1.`, `1.`)  number, letter or Roman numeral, each followed by either a period or right parenthesis, then exactly one space, then text content.
* Since Markua supports letters and Roman numerals as well as decimal numbers to start lists, the rules about using consecutive numbers or the same number are actually a bit complex. These are discussed later.
* You need to follow the period or parenthesis with exactly one space. Markua very deliberately does not allow more than one space following the period or right-parenthesis: if your list grows to 10 or more items, you should not waste time adding a space to items 1-9 to line their content up with item 10; similarly, if your list grows to 100 or more items you should not waste time adding yet another space to items 1-99 to line their content up with item 100. So, Markua just forbids more than one space after the period or parenthesis. Besides the time saved, the increased consistency is a benefit.

Note that a Markua Processor must output the same number, letter or Roman numeral which is in the manuscript. A Markua Processor may choose to respect the parentheses versus period decision, or it may choose to use all periods or all parentheses, or it may choose to use parentheses in, say, PDF, but use periods in, say, HTML, EPUB and MOBI. There is no formal, official mapping of Markua to any output format, to encourage competition and dynamic ecosystem of Markua Processors.

This set of examples shows many of the normal use cases of lists with the various numbering systems. For the edge cases, see the next sections.

You can build a numbered list out of ascending decimal numbers starting from 1:

~~~
1. foo
2. bar
3. baz
~~~

You can build a numbered list out of ascending decimal numbers starting from 1, with parentheses used instead of periods:

~~~
1) foo
2) bar
3) baz
~~~

You can build a numbered list out of ascending decimal numbers followed by periods starting from a higher number:

~~~
9. foo
10. bar
11. baz
~~~

You can build a numbered list out of ascending decimal numbers followed by parentheses starting from a higher number:

~~~
9) foo
10) bar
11) baz
~~~

You can build a numbered list out of descending decimal numbers:

~~~
3. foo
2. bar
1. baz
~~~

You can build a numbered list out of identical decimal numbers, if you are lazy (producing 1, 2, 3):

~~~
1. foo
1. bar
1. baz
~~~

You can build a numbered list out of ascending lowercase letters:

~~~
a. foo
b. bar
c. baz
~~~

You can build a numbered list out of ascending lowercase letters, with parentheses used instead of periods:

~~~
a) foo
b) bar
c) baz
~~~

You can build a numbered list out of ascending uppercase letters:

~~~
I. foo
J. bar
K. baz
~~~

You can build a numbered list out of ascending uppercase Roman numerals:

~~~
I. foo
II. bar
III. baz
~~~

You can build a numbered list out of ascending lowercase Roman numerals:

~~~
i. foo
ii. bar
iii. baz
~~~

You cannot, however, indent your numbered list delimiters. The following is not a list, but instead is an oddly-formatted paragraph:

~~~
 8. foo
 9. bar
10. baz
~~~

### In Markua, It's Hard to Accidentally Make a Numbered List

Markdown has the interesting combination of supporting one element lists and ignoring the number that a list starts with. This means it's possible to inadvertently start a numbered list by beginning any line with a number followed by a period. The example that John Gruber [cites](http://daringfireball.net/projects/markdown/syntax) is the following:

`1986. What a great season.`

In Markdown, this would produce the following single-element numbered list:

`1. What a great season.`

In my opinion, is a blatant violation of the Principle of Least Surprise. (By the way, there is a very gross workaround in Markdown: you prefix the period with a backslash. So, you'd write `1986\. What a great season.` to avoid this.)

Now, if Markua supported single-element numbered lists, this would produce a single-element numbered list:

`1986. What a great season.`

This wouldn't be as bad as what Markdown does, but it wouldn't be good either! Exactly how stupid it would look would be determined by how numbered lists were formatted by the Markua Processor, but it certainly would look wrong.

But what to do?

What Markua does is define a number of common-sense use cases which *do* make numbered lists, and then backs out the rule which results. The resulting rule is as follows:

**In Markua, a single element numbered list is a numbered list if at least one of the following is true: it uses a parenthesis for its delimiter, it contains a nested list, or it is itself a child of some list item in a list.**

So, something like this is not a list in between two paragraphs. Instead, it's three paragraphs, like you would expect:

~~~
Yada yada yada

1986. What a great season.

Yada yada yada
~~~

This is true for numbered lists only--single-element bulleted lists are lists. (It's stupid, but the alternative would have been stupider.)

~~~
Yada yada yada

* This is a list

Yada yada yada
~~~

So, in Markua, the automatic creation of a numbered list only happens if you have two or more lines starting with consecutive or identical numbers, letters or Roman numerals, followed by a period or right parenthesis, followed by a space, followed by text content.

This still has some possibly incorrect interpretations, but these will be a *lot* more rare. This matters: if you get burned by the automatic list creation, and you feel that you have to think about whether you can start a sentence with a number, then writing in Markua would feel more like programming than writing.

#### A Single-Element Numbered List With A Parenthesis Is a Numbered List

This **is** a numbered list:

~~~
Yada yada yada

1) Foo

Yada yada yada
~~~

This **is** a numbered list:

~~~
Yada yada yada

1986) Foo

Yada yada yada
~~~

This is **not** a numbered list:

~~~
Yada yada yada

1\) Foo

Yada yada yada
~~~

This is **not** a numbered list:

~~~
Yada yada yada

1986\) Foo

Yada yada yada
~~~

This is **not** a numbered list:

~~~
Yada yada yada

1. Foo

Yada yada yada
~~~

This is **not** a numbered list:

~~~
Yada yada yada

1986. Foo

Yada yada yada
~~~

#### A Single-Element Numbered List Which Contains A List Is A Numbered List

This is a numbered list:

~~~
Yada yada yada

1. Foo
   a) foo
   b) bar
   c) baz

Yada yada yada
~~~

This is a numbered list:

~~~
Yada yada yada

1986. Foo
      a) foo
      b) bar
      c) baz

Yada yada yada
~~~


#### A Single-Element Numbered List Which Is Contained in A List Is A Numbered List

This is a numbered list, including the `a) hello` part at the bottom.

~~~
Yada yada yada

1. Foo
   a) foo
   b) bar
   c) baz
2. Bar
   a) foo
   b) bar
   c) baz
3. Baz
   a) hello

Yada yada yada
~~~

This is a numbered list:

~~~
Yada yada yada

1986. Foo
      a) foo
      b) bar
      c) baz

Yada yada yada
~~~

### Consecutive Lists

The following example contains three paragraphs. The second paragraph contains two consecutive lists, a numbered list and a bulleted list:

~~~
Paragraph one...

Yada yada yada
1. fee
2. fie
-  foe
-  fum
Yada yada yada

Paragraph two...
~~~

### List Items Can Be Empty

This is gross and pointless, but banning this case would be worse. The following are all legal lists:

~~~
* foo
*
* bar

1. foo
2.
3. bar

* lorem
  * ipsum
  *
  * dolor
*
* sit
  *
  * amet

*
*
*

1.
2.
3.
~~~

### Numbered List Numbering Rules

*This section is highly technical, and can be [skipped](#simple-lists) or quickly skimmed by almost all authors. It's probably only interesting to someone writing a Markua Processor.*

There are a number of rules about what does and does not trigger the creation of a numbered list. These rules are designed to help authors stay sane when writing in Markua, and also to help implementors of Markua Processors stay sane. In all cases, the first number, letter or Roman numeral is the start of the list numbering. This never changes.

If, because of the correct application of these rules, a numbered list is not created, what happens is that a paragraph is created instead, with a forced line break for each single newline. In this instance, the output directly matches the input, including all the numbering.

In theory, Markua supports creating a numbered list when either of the following two conditions occur:

1. Every item in the list begins with a consecutive number, either increasing or decreasing.
2. Every item in the list begins with the same number.

This is not actually quite true.

See, the notion of "consecutive" is easy to explain and to check for decimal numbers, either in increasing or decreasing order. `1, 2, 3, ...`, `456, 457, 458, ...`, or `5, 4, 3` are all easily verified as consecutive, both by humans and computers.

However, Markua also supports numbered lists using uppercase and lowercase alphabetical numbering, as well as uppercase and lowercase Roman numeral numbering, and in increasing or decreasing order.

In the case of alphabetical numbering, checking "consecutive" is harder. It's relatively straightforward for the first 26 items, but then all bets are off. In case you're curious, here is the sequence used in HTML for increasing alphabetical numbering:

`a, b, ..., z, aa, ab, ..., az, ba, bb, ... bz, za, zb, ..., zz, aaa, aab, ..., aaz, aba, abb, ...`

In terms of Roman numerals, it's even worse. I'm sure that someone in a Classics department (or in the NFL) knows the algorithm by heart, but I don't.

So, what are Markua authors and implementors of Markua Processors to do?

Markua makes this simpler by specifying the following rules.

Markua *actually* supports creating a numbered list based on a different set of conditions based on the numbering type.

For decimal numbers, Markua actually supports creating a numbered list when either of the following two conditions occur:

1. Every item in the list begins with a consecutive number, either increasing or decreasing.
2. Every item in the list begins with `1.`

For uppercase and lowercase alphabetical numbering, Markua actually supports creating a numbered list when either of the following two conditions occur:

1. Every item in the list begins with a consecutive letter, followed by a period, and the lettering does not extend past `z.` for lowercase, or `Z.` for uppercase. (This way, implementors of Markua Processors don't need to check the `aa`, case, and authors writing in Markua don't need to remember it.)
2. Every item in the list begins with `a.` for lowercase letters or `A.` for uppercase letters.

These rules mean you can't start a list with `aa.` or higher. This is preferable to Markua having many variants of the Markdown `1986.` problem. If you want to write a paragraph starting with "AA.", to write a dramatic statement about either anti-aircraft fire or alcoholism, you would be really surprised to have created a single-element list beginning with "AA" instead!

For uppercase and lowercase Roman numeral numbering, Markua actually supports creating a numbered list when either of the following two conditions occur:

1. Every item in the list begins with a consecutive Roman numeral, followed by a period, and the lettering does not extend past `xii.` for lowercase Roman numerals or `XII.` for uppercase Roman numerals. To be clear, this means that the only valid consecutive lowercase Roman numerals are `i, ii, iii, iv, v, vi, vii, viii, ix, x, xi, xii`, and that the only valid consecutive uppercase Roman numerals are `I, II, III, IV, V, VI, VII, VIII, IX, X, XI, XII`.
2. Every item in the list begins with `i.` for lowercase Roman numerals or `I.` for uppercase Roman numerals.

The combination of the rules for Roman numeral numbering means that you can have an arbitrarily long Roman numeral list starting from `i.` or `I.`, but that implementors of Markua Processors don't need to write code to figure out whether `MCMLXXV` is a valid Roman numeral, and what the consecutive Roman numeral sequence after it is.

If you're wondering why I picked `xii` and `XII` for the last consecutive lowercase and uppercase Roman numerals to respect: this is Roman numeral 12, and the main usage of Roman numerals in modern life is in clock faces.

Speaking of clock faces, I have bad news for fans of watches and antique clocks:

* The only supported version of the Roman numeral 4 is the subtractive `iv` (in lowercase) or `IV` (in uppercase); the additive `iiii` or `IIII` form is not supported.
* The only supported version of the Roman numeral 9 is the subtractive `ix` (in lowercase) or `IX` (in uppercase); the additive `viiii` or `VIIII` form is not supported.

It turns out that the question of additive versus subtractive forms of Roman numerals is actually interesting; see [this article](http://mentalfloss.com/article/24578/why-do-some-clocks-use-Roman-numeral-iiii) and [this Wikipedia entry](https://en.wikipedia.org/wiki/Roman_numerals) for a starting point.

In Markua, list numbers must **all** either be **consecutive**, given the type of numbering that is used, or **the same as the first number**. Otherwise, the list is interpreted as a paragraph with a bunch of break tags in it, and lines starting with the numbers given. The principle is the following: the numbers which are shown in the manuscript must be the same as those in the output, or the numbers must be clearly intended to be numbered list numbers. Otherwise, a list will not be produced.

If you want to prevent a list from being created with consecutive numbered items separated by single newlines, the backslash escape in front of the period used in Markdown to prevent lists also works in Markua. However, it is needed a lot less often.

{#simple-lists}
## Simple Lists

Both bulleted and numbered lists can either be simple lists or complex lists. Whereas the distinction between bulleted and numbered lists was based on the list delimiter, simple and complex lists are distinguished by the indentation and newlines.

Yes, this distinction essentially comes down to the ancient computer science debate of tabs versus spaces.

**A simple list uses one tab per nested indentation level.**

If you use spaces for indentation, what you are creating is a complex list, which is discussed next.

Besides the formatting rules for bulleted or numbered lists, the rules for a simple list are:

* There are no newlines in list items. Each list item in a simple list is one paragraph with no forced line breaks or blank lines.
* You cannot insert resources with attribute lists in list items. These are inserted after forced line breaks or blank lines, both of which require newlines, and there are no newlines in list items of simple lists.
* There is a maximum of **four** levels of nesting of lists, including the outermost list. (So, you can have three levels of nested lists under each outermost list item.)
* If you try to nest a fifth level of nesting (or more), the Markua Processor must raise an error.
* The first indentation level is no indentation: it is at the left margin.
* You must use exactly one tab per nested indentation level.  (So, the number of tabs you can have is 0, 1, 2 or 3.)
* You cannot use spaces to indent list items. Simple lists only contain tabs.

This is an example of a simple list which has the maximum number (four) of levels of nested list:

~~~
1. foo
	a) lorem
		i. unus
			- one
			- two
			- three
		ii. duo
		iii. tres
	b) ipsum
	c) dolor
2. bar
3. baz
~~~

## Flat Lists

The examples of bulleted and numbered lists in the [Bulleted Lists](#bulleted-lists) and [Numbered Lists](#numbered-lists) sections above were *flat lists*, which did not contain any indentation.

Every item in a flat list is at the outermost level, and there are no newlines in list items. A flat list is a special case, in that it conforms to all the rules for *both* a simple list and a complex list.

A flat list is so simple that it is not just a simple list, it's also a complex list. *Whoa.*

## Complex Lists

Whereas simple lists use tabs for indentation and cannot have newlines within list items, **a complex list uses spaces for indentation levels and can have newlines within list items**.

Using spaces allows for a lot more complex formatting of list items which is still understandable, including lining up nested resources and multiple-paragraph list items. So, these are called complex lists not "spaces lists", since the distinguishing feature is the complexity supported by the spaces, not the spaces themselves.

Besides the formatting rules for bulleted or numbered lists, the rules for a complex list are:

* Complex lists only contain spaces. You cannot use tabs to indent list items or line up content in list items. If you like hitting the tab key, ensure that you set your text editor to convert tabs to spaces.
* Each list item in a complex list can be one or more paragraphs, and each paragraph can contain forced line breaks. Specifically, there can be forced line breaks (formed by single newlines) and blank lines (formed by exactly two consecutive newlines) in list items.
* You can insert resources with attribute lists in list items. These are inserted after forced line breaks or blank lines.
* After any forced line break or blank line, the content (including a nested list) must be lined up with the beginning of the content in the above line using the appropriate number of spaces (not tabs). This rule is discussed further in the [Complex List Indentation](#complex-list-indentation) section below.
* There is a maximum of **four** levels of nesting of lists, including the outermost list. So, you can have three levels of nested lists under each outermost list item.
* If you try to nest a fifth level of nesting (or more), the Markua Processor must raise an error.
* The first indentation level is no indentation: it is at the left margin.

A> Yes, this is one of the reasons why simple lists cannot contain newlines inside list items. If that was allowed, the natural thing to do would be to support using tabs and spaces to align complex content in those list items. However, what this would also result in would be that converting tabs to spaces could break a list: if we allowed tabs to be used to align subsequent paragraphs in a list item, then converting those tabs to spaces could, in certain cases, result in an incorrect number of spaces being used. This would then result in a valid list becoming an invalid list. A common text editor setting which modifies formatting in an invisible way should not be able to break a Markua document, so forcing tab-indented lists to be simple lists ensures that this is the case. This is preferable to either banning tabs (since many people prefer tabs) or to attempting to support complex lists using tabs (which would be both brittle and confusing).

As discussed, if you attempt to nest more than four levels of nesting, the Markua Processor must raise an error. However, if you violate the indentation rules or newline rules of both simple lists and complex lists, the Markua Processor must just interpret your list as normal non-list content, such as a paragraph with line breaks. The reason for this is simple: every block element which is not a list violates the rules for lists--otherwise it would be a list! So, the only "this is not a list" property which actually causes an error is an attempt to add more that four levels of nesting to a simple or complex list. Any other mistake just results in the list being not a list, in order to be more permissive about how Markua documents can be formatted.

### Complex List Examples

You can do everything with a complex list that you can do with a simple list. This is a complex list which is the equivalent of the nested list from the simple list example above:

~~~
1. foo
   a) lorem
      i. unus
         - one
         - two
         - three
      ii. duo
      iii. tres
   b) ipsum
   c) dolor
2. bar
3. baz
~~~

However, you can do a lot more with a complex list as well.

First, you can add optional blank lines between the items for readability.

Note that the same decision must apply for each list level: you can't have blank lines between some items in a list and not others. You can, however, have blank lines between items in one level but not in others. Here's an example of using blank lines in the outer list and in the first nested list, but not in the second and third nested lists:

~~~
1. foo

   a) lorem
      i. unus
         - one
         - two
         - three
      ii. duo
      iii. tres

   b) ipsum

   c) dolor

2. bar

3. baz
~~~

You can make multiple paragraph list items using blank lines, and add forced line breaks using single newlines:

~~~
1. This is the first paragraph in the first item in the list.

   This is the second paragraph in the first item in the list. It is followed by a nested list.

   a) lorem
      i. unus
         - This is part of the first list item in a nested list.
           This is still part of the first list item in a nested list, with a forced line break.
         - two
         - three
      ii. duo
      iii. tres

   b) ipsum

   c) dolor

2. bar

3. baz
~~~

Note that the amount of space to indent is determined by the content, and that is determined by the width of the number:

~~~
9. This is the first item in the list.
   This is still part of the first item in the list.
   a) lorem
   b) ipsum
   c) dolor
10. This is the second item in the list.
    This is still part of the second item in the list.
    a) lorem
    b) ipsum
    c) dolor
~~~

This is a numbered list which contains five list items. It includes an inline code resource, a local code resource, and multiple-line list items:

~~~
1. This is part of the first item in the list.
   ```ruby
   puts "hello"
   ```
   This is still part of the first item in the list.
2. This is the second item in the list.
   {format: ruby}
   ![Hello, World](hello.rb)
   This is still part of the second item in the list.
3. This is the third item in the list.
   This is still part of the third item in the list.
4. This is the fourth item in the list.
   This is still part of the fourth item in the list.
5. This is the fifth item in the list.
~~~

This is a bulleted list with the same complexity:

~~~
* This is part of the first item in the list.
  ```ruby
  puts "hello"
  ```
  This is still part of the first item in the list.
* This is the second item in the list.
  {format: ruby}
  ![Hello, World](hello.rb)
  This is still part of the second item in the list.
* This is the third item in the list.
  This is still part of the third item in the list.
* This is the fourth item in the list.
  This is still part of the fourth item in the list.
* This is the fifth item in the list.
~~~

Neither the numbered or bulleted list above had multiple paragraphs in it, just forced line breaks. This is what those lists look like with multiple paragraphs instead...

This is the numbered list version:

~~~
1. This is part of the first item in the list.

   ```ruby
   puts "hello"
   ```

   This is still part of the first item in the list.

2. This is the second item in the list.

   {format: ruby}
   ![Hello, World](hello.rb)

   This is still part of the second item in the list.

3. This is the third item in the list.

   This is still part of the third item in the list.

4. This is the fourth item in the list.

   This is still part of the fourth item in the list.

5. This is the fifth item in the list.
~~~

This is the bulleted list version:

~~~
* This is part of the first item in the list.

  ```ruby
  puts "hello"
  ```

  This is still part of the first item in the list.

* This is the second item in the list.

  {format: ruby}
  ![Hello, World](hello.rb)

  This is still part of the second item in the list.

* This is the third item in the list.

  This is still part of the third item in the list.

* This is the fourth item in the list.

  This is still part of the fourth item in the list.

* This is the fifth item in the list.
~~~

To reiterate, single blank lines (two newlines) make paragraphs, and forced line breaks (single newlines) stay in the same paragraph.

~~~
Here's a paragraph before the list.

1. This is the first paragraph in the first list item. Yay!

   This is a second paragraph in the first list item.

2. The second list item is boring.

3. The third list item has three paragraphs. This is the first paragraph.
   This is still part of the first paragraph.

   Here's the second paragraph in the third list item.

   Here's the third paragraph in the third list item.

Here's a paragraph after the list.
~~~

### Blank Lines in Complex Lists

#### Single Blank Lines Within Complex List Items

It is legal to add single blank lines in between list items, to separate the list item into multiple paragraphs.

If there is a blank line within a list item, there **must** also be a blank line at the end of the list item.

The reason for this is simple: since paragraphs are separated by blank lines, and since lists support multiple-paragraph list items, you need to add a blank line at the end of a multiple-paragraph list item for symmetry. Otherwise, you can write something ugly like this:

~~~
1. foo

   bar
2. baz
~~~

The above example is so ugly it's not a legal Markua complex list, and instead must be interpreted as paragraphs.

The correct way to write it is:

~~~
1. foo

   bar

2. baz
~~~

#### Two Consecutive Blank Lines End A Complex List

Whereas one blank line can be used in between list items for spacing or between other list item content to separate it into paragraphs, two blank lines always end a list and start a new block element, such as a paragraph or a new list.

There is no reason to be able to add two blank lines in between list items. However, there are reasons to wish to have two lists in a row in a Markua document. So, two blank lines in between two list items stops the previous list and starts a new list. There is no need to use some kind of garbage syntax to separate lists--just add an extra blank line.

Note, however, that two blank lines between single-element numbered lists would actually not produce two numbered lists since, again, in Markua single-element numbered lists *are not lists*.

This all sounds a bit complex, but it actually results in behaviour which is as unsurprising as possible to the author, and a lot less surprising than standard Markdown. This is shown by the following examples...

This is one flat list, which is both as simple list and a complex list:

~~~
* list one item one
* list one item two
* list one item three
~~~

This is one list. Since there are blank lines, it's a complex list:

~~~
* list one item one

* list one item two

* list one item three
~~~

These are two flat lists. Again, flat lists are both simple lists and complex lists:

~~~
* list one item one
* list one item two
* list one item three


* list two item one
* list two item two
* list two item three
~~~

These are two complex lists:

~~~
* list one item one

* list one item two

* list one item three


* list two item one

* list two item two

* list two item three
~~~

These are two flat lists. The first is a one-element list; the second is a three-element list:

~~~
* list one item one


* list two item one
* list two item two
* list two item three
~~~

These are also two flat lists. The first is a one-element list; the second is a three-element list:

~~~
* list one item one


* list two item one

* list two item two

* list two item three
~~~

These are two flat lists:

~~~
1. list one item one
2. list one item two
3. list one item three


1. list two item one
2. list two item two
3. list two item three
~~~

These are two complex lists:

~~~
1. list one item one

2. list one item two

3. list one item three


1. list two item one

2. list two item two

3. list two item three
~~~

This is a normal paragraph followed by a flat list, since single-element numbered lists are not lists. This example shows the correctness of this decision:

~~~
1986. What a great season.


1. list one item one
2. list one item two
3. list one item three
~~~

This is also a normal paragraph followed by a flat list, since, again, single-element numbered lists are not lists. This highly-contrived example will confuse anyone reading your manuscript:

~~~
1. This is actually a paragraph not a list, since single-element numbered lists are not lists.


2. list one item one
3. list one item two
4. list one item three
~~~

This is also a normal paragraph followed by a complex list, but this more-contrived example would confuse anyone reading your manuscript:

~~~
1. This is actually a paragraph not a list.


1. list one item one

2. list one item two

3. list one item three
~~~

Again, this is also a normal paragraph followed by a complex list, but this even-more-contrived example would confuse anyone reading your manuscript:

~~~
1. This is actually a paragraph not a list.


2. list one item one

3. list one item two

4. list one item three
~~~

### Inline Code Resources Inside List Items

When inserting a code resource as an inline resource in a list item, it must be indented to line up with the list item content it is a sibling of.

For example, in the following list, the inline code blocks are indented by three spaces:

~~~
1. This is part of the first item in the list.

   ```ruby
   puts "hello"
   ```

   This is still part of the first item in the list.

   ```java
   public class Hello {
       public static void main(String[] args) {
           System.out.println("hello");
       }
   }
   ```

2. This is the second item in the list.
~~~

When the code itself is output, the number of spaces that the list was indented by must be subtracted from the output by the Markua Processor.

So, when this list is output, in the first example, `puts "hello"` and `public class Hello {` would both start with no indentation, while the `       public static void main(String[] args) {` line would be output with 4 spaces of indentation, not 7.

{#complex-list-indentation}
### Complex List Indentation

The rule for complex list indentation is as follows:

"After any forced line break or blank line, the content (including a nested list) must be lined up with the beginning of the content in the above line using the appropriate number of spaces (not tabs). This rule is discussed further in the [Complex List Indentation](#complex-list-indentation) section below."

This rule is very strict, and it has a number of consequences.

First, I want to explain why this rule is the way it is.

The goal is to ensure that all complex lists look the same to every author or editor who works on a manuscript, regardless of their tab settings. Complex lists are, well, complex, and being able to reason clearly about them is important. So, the first goal of the formatting rules is to ensure maximum readability. This is why tabs are banned from complex lists.

Next, in terms of the amount of indentation.

The amount of indentation inside a complex list item is actually *not* arbitrary; **it is completely determined by how many spaces you need to line up with the content in the line above the list item**. For a bulleted list this will always be 2 spaces (1 for the `*` or `-`, followed by 1 for the space); for a numbered list this will always be at least 3 spaces (1 or more for the number/letter/Roman numeral, 1 for the `.` or `)`, and 1 for the space).

Now, this has an important and slightly annoying consequence: while nested lists will always line up with the content of the list item, there are certain situations in which nested lists will not line up with each other.

Specifically, there are three of them which are noteworthy:

1. Numbered lists with decimal numbers which go above 9
2. Numbered lists with uppercase or lowercase letters which go above z
3. Numbered lists with Roman numerals

These situations are shown below.

Numbered lists with decimal numbers which go above 9:

~~~
8. foo
   bar
   a) lorem
   b) ipsum
9. foo
   bar
   a) lorem
   b) ipsum
10. foo
    bar
    a) lorem
    b) ipsum
11. foo
    bar
    a) lorem
    b) ipsum
~~~

Numbered lists with uppercase or lowercase letters which go above z:

~~~
y) foo
   bar
   a) lorem
   b) ipsum
z) foo
   bar
   a) lorem
   b) ipsum
aa) foo
    bar
    a) lorem
    b) ipsum
ab) foo
    bar
    a) lorem
    b) ipsum
~~~

Lists with Roman numerals:

~~~
i) foo
   bar
   a) lorem
   b) ipsum
ii) foo
    bar
    a) lorem
    b) ipsum
iii) foo
     bar
     a) lorem
     b) ipsum
iv) foo
    bar
    a) lorem
    b) ipsum
v) foo
   bar
   a) lorem
   b) ipsum
~~~

Now, frankly, the Roman numeral example looks pretty bad. However, nesting anything inside Roman numerals looks bad. For example, if complex lists in Markua worked with a constant amount of spaces, then they would not line up with the content of the list items.

~~~
This is not a Markua list, and will be output a really ugly paragraph with a bunch of forced line breaks:

i) foo
   bar
   a) lorem
   b) ipsum
ii) foo
    bar
   a) lorem
   b) ipsum
iii) foo
     bar
   a) lorem
   b) ipsum
iv) foo
    bar
   a) lorem
   b) ipsum
v) foo
   bar
   a) lorem
   b) ipsum

Again, the above is not a list.
~~~

So, if you like Roman numerals, my personal advice is to use them either in simple lists (since tabs always line up) or as the lowest level of indentation in a complex list.

{#definition-lists}
# Definition Lists

Definition lists are also supported in Markua. Definition lists are related to lists, but they are neither flat, simple nor complex. Instead, they are what they are: definition lists.

To define a definition list in Markua, use the following syntax:

~~~
term 1
: definition 1

term 2
: definition 2
~~~

There can be one to three spaces after the colon, or one tab.

A definition list can provide multiple definitions for a term:

~~~
term 1
: definition 1a
: definition 1b

term 2
: definition 2
~~~

A single term definition list is a definition list, regardless of how many definitions for the term exist:

~~~
term
: definition
~~~

Finally, like list items in complex lists, each definition list item can contain newlines and multiple paragraphs. What you do here is indent the subsequent lines by the same amount of space as the initial line. (If you do not indent the subsequent lines, then you're ending the definition list and just starting a new paragraph.) As with list items, one newline is a forced line break; two newlines is a new paragraph:

You can nest resources inside a definition list. You cannot nest definition lists inside definition list items, however--that would be highly confusing.

~~~
Here's a paragraph before the definition list.

one
: This is the first definition of one. It's one paragraph.
: This is the second definition of one. It's two paragraphs.

  This is a second paragraph in the second definition of one.

two
: The second definition list item is simple.

three
: The third definition list item has three paragraphs.
  This is definition still part of the first paragraph.

  Here's the second paragraph in the third definition list item.

  Here's the third paragraph in the third definition list item.

ruby
: Here is some Ruby code.

  ```ruby
  puts "hello"
  ```

  Here is some more Ruby code.

  {format: ruby}
  ![Hello, World](hello.rb)

  That's as simple as it gets.

Here's a paragraph after the list.
~~~

Just as with list items, any leading whitespace after the line break is used to continue the definition list item, and is thus ignored. Like list items, definition list items are not poetry.

With the rise of mobile and the narrower screen reading experience becoming the new default, definition lists may end up being more useful than tables in many Markua documents.

Finally, with definition lists, one thing you often want to do is link to a specific definition, not just to the list itself. This is useful to do, since in a document with many definitions, it's helpful if the reader scrolls to the right spot or opens to the right page.

To do this, just define a span id on the element itself, and then link to it.

~~~
foo{#foo}
: This is foo.

bar{#bar}
: This is bar.
~~~

Note that if you define an id attribute above the first definition list item, what you are doing is defining an id on the entire definition list. As such, this does not work on any subsequent list item: in the following definition list, the `{#definitions}` is the id of the definition list. It is not the id of foo.

~~~
{#definitions}
foo{#foo}
: This is foo.

bar{#bar}
: This is bar.
~~~

To be clear, the following is not legal Markua:

~~~
This is not legal.

foo
: This is foo.

{#bar}
bar
: This is bar.

This is not legal.
~~~

If there was an id above foo, it would be legal, since it would be the id of the entire definition list. However, the id attribute above bar is not legal. A Markua Processor should ignore this id, and add an error to the list of errors.

# Block Elements

Broadly speaking, Markua documents consist of three things: block elements, span elements and metadata. Paragraphs, headings, figures and lists, all discussed earlier in this specification, are examples of block elements. Block elements are separated from each other by at least one blank line.

These are the remaining block elements defined by Markua.

{#scene-breaks}
## Scene Breaks (`* * *`)

In fiction, scene breaks are sometimes added between paragraphs in a chapter to denote a break in context. To add a scene break, add three or more asterisks on a line by themselves, with or without spaces between them. For example, `***`, `* * *` and `**********` on a line by themselves all produce a scene break.

Example:

~~~
This is before the scene break.

* * *

This is after the scene break.
~~~

Markua Processors can take great liberties in how they output scene breaks. They can output a set number of asterisks, or an image, or whatever else they choose. Note that typically a scene break is not followed by a page break. However, to add this, you can simply add a manual page break after it.

{#page-breaks}
## Page Breaks (`===`)

Three or more equals signs on a line by themselves, with or without spaces between them (e.g. `===`, `= = =`, `==========`, etc.), produce a page break.

Page breaks are discouraged in Markua: when you're writing, unsemantic formatting is procrastination, and most page breaks are exactly this. Much like width and height attributes on images, however, page breaks are supported in Markua due to pragmatic concerns.

Here is an example showing a page break following a paragraph, and a page break following a scene break:

~~~
This is before the page break.

===

This is on a new page, after the forced page break. It has a scene break and then a page break after it.

* * *
===

This is on a new page, after the scene break and the forced page break.
~~~

## Blockquotes (`>`)

Blockquotes in Markdown are created by prefacing lines with `> `, i.e. a greater than character followed by a space:

~~~
This is the first paragraph.

> This is a blockquote.
>
> It is outside the paragraphs.

This is the second paragraph.
~~~

Blockquotes in Markua are created in one of two ways:

1. By prefacing lines with `> `, i.e. a greater than character followed by a space.
2. By wrapping the blockquote in `{blockquote}` ... `{/blockquote}`

Option #1 is preferable for short quotes; option #2 is easier on authors for really long quotes.

Like figures and tables, blockquotes can be inserted in the middle of a paragraph or as a sibling of it.

A> For non-programmers: I'm calling these things "blockquotes", not "block quotes", since their origin is in Markdown [blockquotes](http://daringfireball.net/projects/markdown/syntax#blockquote), and since they can be inserted by typing `{blockquote}`. If I called them "block quotes", that might encourage someone to incorrectly try to insert them as `{block quote}`, which would not work.

These Markua blockquotes are siblings of the paragraphs:

~~~
This is the first paragraph.

> This is a blockquote.
>
> It is outside the paragraphs.

This is the second paragraph.

{blockquote}
This is a blockquote.

It is outside the paragraphs.
{/blockquote}

This is the third paragraph.
~~~

These Markua blockquotes are nested in the paragraph:

~~~
This is the first paragraph.

This is the second paragraph.
> This is a blockquote
>
> It is inside the second paragraph.
This is part of the second paragraph.
{blockquote}
This is a blockquote.

It is inside the second paragraph.
{/blockquote}
This is part of the second paragraph.

This is the third paragraph.
~~~

A blockquote can contain other block-level elements, most commonly paragraphs.

If you are using the `{blockquote}` ... `{/blockquote}` approach, this is trivial: just pretend you're in a normal paragraph, and the syntax is the same.

If you are using the Markdown approach of `>`, then to start a new block level element within a blockquote, just put a line starting with a `>` followed by a space, followed by the block level element. It is equivalent to placing a `>` and a space in front of every line of the paragraphs.

In Markdown, a single newline inside a blockquote (where both lines are preceded by a `>` and a space) adds a single space. In Markua, however, a single newline inside a blockquote adds a forced line break. This is identical to how single newlines inside a normal Markua paragraph function. This is discussed at length in the [Single Newlines](#single-newlines) section earlier. Note that it means you **cannot** manually wrap blockquotes to make them look nicer. Manually wrapping blockquotes is tedious and discourages editing of your own work. If you have really long blockquotes which span multiple paragraphs, the `{blockquote}` syntax is more pleasant to write in.

Blockquotes can be multi-paragraph. To create a multi-paragraph blockquote, you need to separate each paragraph with a line containing a `>` and (optionally) whitespace.

If a blockquote contains headings, these headings may be formatted by a Markua Processor differently than normal headings. Finally, if a Markua Processor is automatically generating a [Table of Contents](#toc) from chapter and section headings, any headings inside blockquotes should be ignored.

A blockquote can have a citation. This is done via the attribute list, which can include a `cite` attribute with the text of the citation and a `url` attribute with the URL of the citation. If both are specified, the text of the citation is linked to the URL. If only the `cite` attribute is specified it is shown as text; if only the `url` is specified it is inserted as text with a link to itself.

The attribute list can be used regardless of which syntax is used to insert the blockquote:

~~~
Lots of people have opinions about software.

Here's the most famous recent one:

{cite: "Marc Andreessen", url: "http://www.wsj.com/articles/SB10001424053111903480904576512250915629460"}
> Software is eating the world.

It's quoted a lot, so let's quote it again:

{blockquote, cite: "Marc Andreessen", url: "http://www.wsj.com/articles/SB10001424053111903480904576512250915629460"}
Software is eating the world.
{/blockquote}

That's it!
~~~

{#asides}
## Asides (`A>` or `{aside}`)

Since Markua is for writing books, including technical books, it needs not just a syntax for blockquotes--it also needs a syntax for asides and for blurbs. These syntaxes are very similar to the Markua syntax for blockquotes. Like blockquotes, any headings inside asides or blurbs do not show up in a Table of Contents (if one is present), and they can also be formatted differently by Markua Processors.

We will consider asides first.

Asides are typically short or long notes in books which are tangential to the main idea--sort of like footnotes, but in the body text itself. In technical books, quite often they are formatted in a box. Asides can span multiple pages.

The syntaxes for asides are very similar to blockquotes:

1. By prefacing lines with `A> `, i.e. an `A`, then a greater than character (`>`), then a space.
2. By wrapping the aside in `{aside}` ... `{/aside}`

Option #1 is preferable for short asides; option #2 is easier on authors for really long asides.

For consistency with blockquotes, asides can be siblings of paragraphs or nested in them.

Here's a short aside:

~~~
A> This is a short aside.
~~~

Here's a longer aside, which also contains a heading:

~~~
A> # A Longer Aside
A>
A> This is a longer aside.
A>
A> It can have multiple paragraphs.
A>
A> The `A> ` stuff can get tedious after a while.
A>
A> This is why the `{aside}` syntax exists.
~~~

Here's a longer aside using the `{aside}` syntax, which also contains a heading:

~~~
{aside}
# A Note About Asides

This is a longer aside.

It can have multiple paragraphs.

Asides can also have headings, like this one does.

Multi-paragraph asides are more pleasant using this syntax.
{/aside}
~~~

{#blurbs}
## Blurbs (`B>` or `{blurb}`)

Blurbs are like asides, but shorter. A blurb is not intended to span multiple pages of output.

The syntaxes for blurbs are very similar to asides:

1. By prefacing lines with `B> `, i.e. a `B`, then a greater than character (`>`), then a space.
2. By wrapping the blurb in `{blurb}` ... `{/blurb}`

Examples:

~~~
B> This is a short blurb.
~~~

~~~
B> # A Longer Blurb
B>
B> This is a longer blurb.
B>
B> It can have multiple paragraphs.
~~~

~~~
{blurb}
#A Longer Blurb

This is a longer blurb.

It can have multiple paragraphs.
{/blurb}
~~~

### Supported Attributes for Blurbs

Blurbs also have support for an attribute list, which can contain a `class` attribute as well as other implementation-specific "extension attributes".

#### Blurb `class` Types

Markua has its origin in authoring computer programming books. In computer programming books, there are a number of blurb types which are a de facto standard:

* `center`
* `discussion`
* `error`
* `information`
* `tip`
* `warning`

These blurb types can be set on a blurb as its `class` attribute. A Markua Processor can optionally style these blurbs appropriately based on the class, for example by adding custom icons for each class of blurb.

Here's how this looks with the `B> ` syntax:

~~~
{class: warning}
B> This is a warning!
~~~

Here's how this looks with the `{blurb}` syntax:

~~~
{blurb, class: warning}
This is a warning!
{/blurb}
~~~

A> The attribute list must either directly precede the `B>` with no blank line between it and the `B>`, or it must be combined with the `{blurb}` block opening. It is not legal Markua syntax to have an attribute list preceding a `{blurb}` block opening like this:
A> `{class: warning}`
A> `{blurb}`

### Syntactic Sugar for Specific Blurb Classes: `D>`, `E>`, `I>`, `Q`, `T`, `W>`, `X>`

Having to constantly type `{class: warning}` in a computer programming book with a number of warnings would get tedious, as would any of the other blurb classes listed above.

So, Markua defines a standard shorthand syntax for these classes of blurbs. With this syntax, you use a different letter than `B` in the `B>`, to create a blurb with the appropriate `class`.

These are the syntactic sugar values you can use which have a heritage in computer programming books:

| Sugar | Equivalent To a B> With |
|-------|-------------------------|
| `D>`  | `{class: discussion}`   |
| `E>`  | `{class: error}`        |
| `I>`  | `{class: information}`  |
| `Q>`  | `{class: question}`     |
| `T>`  | `{class: tip}`          |
| `W>`  | `{class: warning}`      |
| `X>`  | `{class: exercise}`     |

Examples:

~~~
D> This is a discussion blurb.

E> This is an error blurb.

I> This is an information blurb.

Q> This is a question blurb.

T> This is a tip blurb.

W> This is a warning blurb.

X> This is an exercise blurb.
~~~

These are equivalent to:

~~~
{class: discussion}
B> This is a discussion blurb.

{class: error}
B> This is an error blurb.

{class: information}
B> This is an information blurb.

{class: question}
B> This is a question blurb.

{class: tip}
B> This is a tip blurb.

{class: warning}
B> This is a warning blurb.

{class: exercise}
B> This is an exercise blurb.
~~~

These are *also* equivalent to:

~~~
{blurb, class: discussion}
This is a discussion blurb.
{/blurb}

{blurb, class: error}
This is an error blurb.
{/blurb}

{blurb, class: information}
This is an information blurb.
{/blurb}

{blurb, class: question}
This is a question blurb.
{/blurb}

{blurb, class: tip}
This is a tip blurb.
{/blurb}

{blurb, class: warning}
This is a warning blurb.
{/blurb}

{blurb, class: exercise}
This is an exercise blurb.
{/blurb}
~~~

Note that `Q>` and `X>` are a bit controversial:

* `Q>` defines a blurb which is formatted like a question, but `{quiz}` (discussed later) defines a quiz, and quizzes have actual numbered questions in them. It is unfortunate that the words `quiz` and `question` both start with the letter `Q`, and that the `question` blurb is not the same thing as a question in a quiz.
* `X>` defines a blurb which is formatted like an exercise, but `{exercise}` (discussed later) defines a structured exercise similar to a quiz. It is unfortunate that the term "exercise" is used for both.

There are issues, in both cases. However, the alternative is worse: removing the `Q>` or `X>` syntax would cause issues for every author who is familiar with, or has a manuscript formatted in, Leanpub Flavoured Markdown. This is not worth the reduced functionality, just to avoid one possible bit of confusion and one naming collision. So, the `Q>` and `X>` blurb syntactic sugar do exist, as do the `{class: question}` and `{class: exercise}` full blurb syntaxes.

Also note that nothing in this section defines what a Markua Processor must *do* with the given class of blurb. Leanpub, for example, uses it to add an appropriate icon from [Font Awesome](https://fortawesome.github.io/Font-Awesome/) at the left of the blurb, but other Markua Processors are free to do something different.

Finally, note that specifying a class in metadata overrides what the syntactic sugar does:

~~~
{class: tip}
W> This is a tip blurb, not a warning blurb.
~~~

A Markua Processor is free to either override this silently, or to raise an error if this happens.

### Using Blurbs to Center Text with `C>`

You can also use a blurb to center text.

The following two ways to do this are equivalent:

~~~
C> This is a centered blurb.

{class: center}
B> This is a centered blurb.
~~~

This is the only way to center text in Markua.

Unlike other blurb types which have their origin in technical books, centering text has a wide range of uses. So, it could have been thought of as something different than a blurb. However, in terms of its behaviour and the way it's inserted, centered text is a blurb--whether it's inserted via syntactic sugar or via a class attribute on a normal blurb element. So, it's discussed here.

### Using Extension Attributes on Blurbs to add `icon` Support

Markua Processors must ignore any attributes which they do not understand.

Because of this, Markua attribute lists can contain any number of extension attributes. An extension attribute is an attribute which is not defined in the Markua specification, but which is understood by some specific Markua Processor.

As an example of an extension attribute, Leanpub adds an `icon` attribute to blurbs. Markua does not specify that a blurb must support an `icon` attribute, or what it would mean if it did. However, Leanpub understands an `icon` attribute to reference an icon from Font Awesome. The value of this attribute is assumed to be the name of an icon in Font Awesome, without the `fa-` prefix.  So, in Leanpub, you can do this:

~~~
{icon: car}
B> You can't spell carbon without it!

{icon: leanpub}
B> Yes, we're in Font Awesome!

{icon: github}
B> So is GitHub, of course. Unicorns.
~~~

In Leanpub, this will produce a nice icon of a car, using the Font Awesome icon. In a Markua implementation that does not understand the icon attribute, nothing will be generated for that attribute--it will be functionally equivalent to the attribute not being present.

{#inserting-into-paras}
## Inserting Block Elements Inside Paragraphs

Many block elements such as lists and figures can also be inserted nested in a paragraph. The way this is done is to add single newlines instead of blank lines.

This example shows a list nested in the middle of a paragraph:

~~~
This is paragraph one.

This sentence is in paragraph two.
* this list is
* part of
* paragraph two
This sentence is also in paragraph two.

This is paragraph three.
~~~

This example shows a figure which is an inline code resource nested in the middle of a paragraph:

~~~
This is paragraph one.

This sentence is in paragraph two.
```ruby
puts "hello world"
```
This sentence is also in paragraph two.

This is paragraph three.
~~~

This example shows a figure which is a local code resource nested in the middle of a paragraph:

~~~
This is paragraph one.

This sentence is in paragraph two.
{format: ruby}
![Hello, World](hello.rb)
This sentence is also in paragraph two.

This is paragraph three.
~~~

This example shows figures which are local or web image resources nested in the middle of paragraphs. Note that as with all figures, the square bracket text in both cases is the figure caption (not alt text):

~~~
This is paragraph one.

This sentence is in paragraph two.
![A Piece of Cake](cake.jpg)
This sentence is also in paragraph two.

This sentence is in paragraph three.
{alt: "a slice of chocolate cake"}
![A Piece of Cake](http://markua.com/cake.jpg)
This sentence is also in paragraph three.

This is paragraph four.
~~~

It is possible to insert a block element as the last part of a paragraph by adding a single newline before it, but a blank line after it:

~~~
This is paragraph one.

This sentence is in paragraph two.
* this list is
* part of
* paragraph two

This is paragraph three.
~~~

This works for most block elements, like lists, figures and tables. It does **NOT** work for definition lists, since those rely on blank lines in between elements.

## Quizzes and Exercises

The final two block elements that Markua provides are quizzes and exercises. These two block elements are very special, however, in that they enable a single Markua document to construct everything from traditional textbooks and paper-based quizzes to entire online courses (or MOOCs). So, they're discussed in [their own chapter](#courses).

# Span Elements

We've already seen many examples of span elements in this specification, especially in the resources section showing resources inserted as spans. These are the rest of them...

## Links

Markua's hyperlink support is a subset of that of Markdown. The **inline** link syntax is supported, as is the **automatic link** shortcut.

### Inline Links

The normal way to create a link is as follows:

~~~
[link text](absolute_url)
~~~

Example:

~~~
Markua was developed at [Leanpub](http://leanpub.com).
~~~

### Automatic Links

To create a link where the text displayed for the link text is the URL itself, the automatic link syntax can be used. In this syntax, an absolute URL is enclosed in angle brackets.

~~~
Some text <absolute_url> some text.
~~~

Example:

~~~
Markua was developed at <http://leanpub.com>.
~~~

## Explicitly Creating Spans with `[`...`]`

Surrounding text in square brackets can be useful not just for giving it a URL to link to. If you wish to add attributes to an arbitrary span of text, you can create an arbitrary span of text using square brackets and then add an attribute list immediately afterward:

~~~
Some text [then a span]{and: an, attribute: list} attached to the span.
~~~

You can use any attribute list on this span, and you can also just use the id syntactic sugar `{#theid}` on this span. The most common uses of this are to add `id`s or index entries, which are discussed later.

Note, however, that you cannot start a normal span with a caret (`^`): this creates a `[^footnote]` instead. (Footnotes are discussed below.)

### Sometimes a Square Bracket is Just a Square Bracket

If there are no round brackets or curly braces immediately after some text in square brackets, the text in square brackets is just that: text in square brackets. In this case, the square brackets are output as normal text.

This is useful when you want to [sic.] something, etc.

## Footnotes and Endnotes

### Footnotes

Books often have footnotes.

To add a footnote, you insert a footnote tag using square brackets, a caret and the tag, like this:

~~~
This has a footnote[^thenote].
~~~

Then, you define the footnote later in the document, using the same square brackets, caret and tag, followed by a colon, a space and the footnote definition:

~~~
[^thenote]: This is the footnote content.
~~~

If you wish to write multiple paragraphs in the footnote, you must indent the subsequent paragraphs by four spaces or one tab:

~~~
This has a footnote[^thenote].

Here is some unrelated text.

[^thenote]: This is the first paragraph of footnote content.

    This is the second paragraph of footnote content.

Here is some more unrelated text.
~~~

Whether the numbering of footnotes restarts every chapter is something that can be specified by the [`restart-footnote-numbering`](#setting-keys-and-values) setting.

### Endnotes

Books often have endnotes. Sometimes these are instead of footnotes, but other times, these are in addition to footnotes. So, it makes sense for Markua to define separate syntaxes for both, rather than just defining one "footnote or endnote" syntax and letting the author pick whether the notes are footnotes or endnotes via a global setting.

To add an endnote, you insert an endnote tag using square brackets, two carets and the tag, like this:

~~~
This has an endnote[^^thenote].
~~~

Endnotes are like footnotes, but happier (`^^`).

Then, you define the endnote later in the document, using the same square brackets, two carets and tag, followed by a colon, a space and the endnote definition:

~~~
[^^thenote]: This is the endnote content.
~~~

Just as with footnotes, if you wish to write multiple paragraphs in an endnote, you must indent the subsequent paragraphs by four spaces or one tab.

Whether the numbering of endnotes restarts every chapter is something that can be specified by the [`restart-endnote-numbering`](#setting-keys-and-values) setting.

### Single Reference to Footnotes and Endnotes

You can only refer to a footnote or endnote once. You can't define a footnote or endnote in one place and refer to it multiple times in the same Markua document. If you wish to refer to a parenthetical piece of text from multiple places in a Markua document, the best approach is to put it in a section (or sub-section, sub-sub-section, etc.) or aside and refer to it from multiple places using a [crosslink](#crosslinks).

### Footnotes and Endnotes Support Required for Paragraphs Only

A Markua Processor must support footnote and endnote references inserted in normal paragraph content. However, that's it.

However, sometimes authors want to get creative with their footnotes and endnotes. Sometimes they want to add them in headings, or in footnotes or endnotes themselves. This latter style has been used on rare occasions, most notably by David Foster Wallace.

However, supporting inserting footnotes and endnotes in places other than normal paragraph content puts a hugely increased burden on implementors of Markua Processors. As such, there is no requirement for a Markua Processor to support inserting a footnote or endnote anywhere other than in normal paragraph content.

Authors should **not** assume that a particular Markua Processor supports inserting a footnote or endnote anywhere other than in normal paragraph content unless its documentation specifically states that it does. For example, Leanpub only supports inserting footnotes or endnotes in normal paragraph content.

A> In software, [abstractions leak](https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/). Leanpub uses LaTeX for its PDF generation, and presumably many other Markua Processors will as well. In LaTeX, inserting footnotes or endnotes in places like headings, footnotes or endnotes is very problematic. So, it's optional. The best thing about writing a specification for something you are implementing is that there is often a very easy solution to a very difficult implementation problem!

{#crosslinks}
## Crosslinks and ids

There are two parts to making a crosslink.

1. Define an id.
2. Reference that id with a crosslink.

### Defining an id

There are two ways to define an id:

1. Using an id attribute `{id: some-id}`
2. Using a shorter "syntactic sugar" approach: `{#some-id}`

The shorter "syntactic sugar" approach is usually preferred. However, it can look a bit odd in an attribute list with other attributes in it. So, in that case, the `{id: some-id}` syntax is preferred.

W> Note for Leanpub authors: The `{#some-id}` syntax does not currently work when there are other attributes in the attribute list. So, in that case, you must currently use the `{id: some-id}` syntax if you are adding other attributes in a larger attribute list. You currently **CANNOT** add the `{#some-id}` to an attribute list.

In terms of the value of an `id`, it has some special restrictions:

1. The first character in the `id` has to be a lowercase or uppercase letter, i.e. `[a-zA-Z]` if you think in regular expressions.
2. The remaining characters in the `id` have to be a lowercase or uppercase letter or a digit or a hyphen (-) or an underscore (_).
3. You can only define an `id` value once in an entire Markua document, even one that is split over multiple files.

These restrictions ensure that your `id`s can then be linked to by a crosslink from anywhere in the Markua document.

The id needs to be defined on either a block or span element.

A> If an id is defined with an invalid name, the Markua Processor must ignore it and log an error.

#### Defining an id on a Block Element

To define an id on a block element like a paragraph, figure, heading or even a definition list item, you simply stick the id definition on a line above the start of the block element. Note that exactly one newline must separate the attribute list from the block element--if two newlines are used, the attribute list will be interpreted as a directive, and the id won't be correctly applied.

Here's how to use the attribute list syntax to define an id attribute:

~~~
{id: some-id}
This is a paragraph with the id of `some-id`.
~~~

Here's how to use the shorter "syntactic sugar" approach to define an id attribute:

~~~
{#some-id}
This is a paragraph with the id of `some-id`.
~~~

#### Defining an id on a Span Element

To define an id on a span element you simply add the id definition immediately after the span element.

Here's how to use the attribute list syntax to define an id attribute on a span element:

~~~
The word Markua{id: markua} has an id.

Leanpub is based in **Victoria, BC, Canada**{id: victoria}.
~~~

Here's how to use the shorter "syntactic sugar" approach to define an id attribute:

~~~
The word Markua{#markua} has an id.

Leanpub is based in **Victoria, BC, Canada**{#victoria}.
~~~

Here's how to define an id on a custom span:

~~~
The [quick sly fox]{#quick_sly} jumped over the lazy dogs.
~~~

If you want to define an id on a span while also defining other attributes like index entries, the `id:` syntax must be used in a full attribute list:

~~~
The [quick sly fox]{id: quick_sly, i: "Fox, Sly and Quick"} jumped over the lazy dogs.
~~~

### Referencing an `id` With a Crosslink

Regardless of how you defined the id, you then link to it to create a crosslink. To do this, you use the `#` character and the id in a link:

~~~
[link text](#some-id)
~~~

This syntax is intended to be reminiscent of HTML anchor tags, not of `h1` titles in Markua.

Note that order of definition and use does not matter: crosslinks will work regardless of whether the `id` is defined before or after the use of it.

### Rules for `id`s and Crosslinks

* If a Markua document contains duplicate `id` attribute values, the **first** one is used and the subsequent ones are ignored. A Markua Processor should log an error about duplicate `id`s.
* Crosslinks that reference an unused `id` may either be created as a (broken, non-functional) link or be created as normal text (not a link) by a Markua Processor. The Markua Processor should also log an error.

### Referencing Chapter, Section and Figure Heading Names and Numbers in Crosslinks

W> Leanpub authors: this has not been implemented yet

Chapters, sections and figures with captions often have two useful properties for writers:

1. A name which is often short and useful to reference.
2. A number, if numbering is turned on.

Whether the numbers exist is determined by the `number-chapters`, `number-parts` and `number-figures` attributes .

In your writing, it's often desirable to refer to these figures from elsewhere in your book. When creating such a reference, it's helpful to be able to reference the title and number of the chapter, section or figure.

A> Adding a reference to the page number would also be helpful in print, but it is obviously problematic in an ebook, since certain ebook formats have resizable text and since the page displayed by PDF readers is often different than the printed page number, because of front matter Roman numerals. So, Markua doesn't provide any special magical syntax to refer to a page number, in order to discourage it--if Markua did support a reference to a page number, then the next logical step would be to only do so in certain output formats, and then writing Markua text would feel like programming. Instead of this nightmare, a really smart Markua Processor could hypothetically (and with the author's permission) automatically add page number references to these references when producing a print-ready PDF.

Here's how these references to titles and numbers work:

* `#t` is for "title"
* `#n` is for "number"
* `#d` is for "description" (e.g. "Figure", "Chapter", "Section")
* `#f` is for "full title"

So, for "Figure 8.2: Anatomy of a Squirrel", these are:

* `#t` is "Anatomy of a Squirrel"
* `#n` is "8.2"
* `#d` is "Figure"
* `#f` is "Figure 8.2: Anatomy of a Squirrel"

Note that in this example, "Anatomy of a Squirrel" was typed by the author, whereas "Figure 8.2: " was generated by the Markua Processor. It does not matter; both can be referenced.

Also, note that regardless of section level, sections referenced in `#d` or `#f` are all called "Section" (not "Sub-Section", "Sub-Sub-Section", etc.)

The expectation is that `#f` will be used by authors who don't mind verbosity, and #t and #n will be used by authors who prefer control and brevity. The #d is for very lazy authors who like saving keystrokes and/or who don't know whether their publisher will call the code samples "Listing", "Example" or some other word and want to protect themselves against extra work.

The `code-sample-names`, `figure-names` and `table-names` settings control the words used to name things.

Examples:

~~~
This is discussed in [section #n, #t](#crosslinks).

This is discussed in [#f](#crosslinks).

This is discussed in a [#d](#crosslinks) above.

See [chapter #n](#span-elements), which is the best chapter in this book.

This is in figure [#n](#fancy-diagram), arguably the fanciest diagram in this document.
~~~

The only way to reference the title and numbers is in crosslinks. There's no syntax to do so without creating a crosslink--a crosslink is more helpful, since it is clickable, and adding another syntax simply to be less helpful to the reader is a bad idea. Markua has enough syntax as it is.

Note that resources, chapters and sections all have implicit numbering. So, #n always works even if numbering is off. However, you will confuse readers if you refer to numbering they cannot see. Also, if numbering is off, the `#f` must not include either the `#d` or `#n` parts: it will be "Anatomy of a Squirrel" not "Figure 8.2: Anatomy of a Squirrel".

{#charsub}
## Character Substitution

 All Markua documents are written in UTF-8, so to produce any Unicode character, it possible to just use the proper Unicode characters. However, in certain cases, it's desirable for Markua to specify automatic replacement of certain combinations of characters with a Unicode replacement. If a Markua Processor encounters one of these combinations of characters outside of a code block, the Markua Processor must replace the combination of characters with the appropriate Unicode character in the output.

`--`
: To produce an em dash (â€”), what is thought of by non-typography people as a "dash" or a "long dash", you can just type two hyphens (`--`) directly after a non-space character. You can also use the proper Unicode character, U+2014, of course. The following all produce em dashes: `foo--bar, foo-- bar, foo--`.

` --`
: To produce a space followed by an en dash (â€“), or the kind of dash that's wider than a hyphen but narrower than an em dash, you can just type a space, followed by two hyphens (` --`). You can also use the proper Unicode character, U+2013, of course. The following both produce en dashes preceded by spaces: `foo -- bar, foo --`. (With `foo -- bar`, there's a space before and after the en dash; with `foo --`, there's no space after it (e.g. at the end of a paragraph).

`...`
: To produce a horizontal ellipsis (â€¦), you can just type `...`. You can also use the proper Unicode character, U+2026, of course.

### Optional Automatic Curly Quotes Outside of Code Blocks and Spans

A Markua Processor may replace the `"` character with the appropriate "curly quote" at its discretion. This lets `"typography"` become `â€œtypographyâ€`, and `it's` become `itâ€™s` as appropriate.

Note that this is an optional behaviour: a Markua Processor may support this fully, only in some output formats, or not at all.

Also, note that it is **NEVER** acceptable for a Markua Processor to do this, or *any* character substitution, to text inside a code block or code span. In almost all instances this would completely break the code. (If you wonder how I got curly quotes into the code spans for `â€œtypographyâ€` and `itâ€™s` above, it's because I pasted them into the manuscript that way. Just as a Markua Processor doesn't make straight quotes curly in a code span, it doesn't make curly quotes straight in a code span either.)

## Escaping Special Characters with Backslash (`\`)

Curly braces and backticks are special in Markua.

A backslash can "escape" a single character, to prevent it from having any special meaning.

TODO - broaden backslash escape (see CommonMark vs Markdown).

At the beginning of a line, an opening curly brace (`{`) starts an attribute list, and two opening curly braces (`{{`) start a placeholder. In the middle of a block element, an opening curly brace starts an index entry. And, at the top of a manuscript.txt file (if the single file approach is used), an opening curly brace starts a settings block.

So, to use a curly brace as an actual curly brace character, you need to backslash-escape it like this: `\{`. (Note that this does not apply inside code or other resources: Markua does not process anything inside them.)

Similarly, a backtick is special. In text content (such as this paragraph), a backtick starts an inline span resource such as a code resource. And three backticks on a line by themselves start a code block.

## Backticks (`` ` ``)

You can create a code span by using pairs of 1, 2 or 3 backticks to surround a span of text within a paragraph, like this:

~~~
This paragraph has a Ruby `puts "hello"` code span inside it.
~~~

You cannot show a literal backtick in a normal code span, however, since you cannot backslash escape anything inside it. Inside a code span, a backslash is just a backslash.

~~~
This paragraph has a Ruby `puts "hello\tworld"` code span inside it.
~~~

So, if you want to output a backtick in a code span, you need to delimit the code span using two backticks:

~~~
This paragraph has a code span with literal backticks `` `say hello` `` in it.
~~~

{#unicode-entities}
## Unicode Entities with `\u`

Typing obscure Unicode characters is hard. So, markup and programming languages often support outputting entity references to Unicode characters. For example, consider the unicode character with the code point `U+1F602`. In HTML, this is the entity `&#x1F602;` in hexadecimal or `&#128514;` in decimal. In JavaScript and many programming languages it is `\u1F602`. These code points are specified in UTF-16, which is a hexadecimal number containing 16-bits of information.

Markua supports Unicode entity references as well. To output a Unicode character, you can type a backslash (`\`), followed by a `u`, followed by the hexadecimal value of the Unicode code point, followed by a semicolon. For example, you can type `\u1F602;` in Markua. The reason the semicolon is required is to clearly indicate the end of the Unicode hexadecimal value to the Markua Processor.

Some example unicode entities which may be useful for a Markua Processor to support include:

* Soft hyphen: \u00AD;
* Non-breaking space: \u00A0;

Now, there's no guarantee that a given Unicode character will be present in a given font.

If a Markua Processor recognizes that a given Unicode character is not present in the font it is currently using, it may switch to a font that it knows will support that character. However, it is entirely acceptable for a Markua Processor to not do anything fancy, and to just attempt to output the character in the font it is using. In this case, what will typically happen is that the font will output a box in place of the missing character. These boxes are affectionately referred to as "tofu" by font people. (You may also encounter a diamond with a question mark in it in this case.)

## Internationalization

Markua Processors may detect the language of the Markua document and output various text in the correct manner. This includes the localization of things like punctuation, the table of contents, etc.

{#emoji}
## Emoji

In 2015, emoji fully arrived. The 2015 Oxford Dictionaries Word of the Year [was](http://blog.oxforddictionaries.com/2015/11/word-of-the-year-2015-emoji/), in fact, the Face with Tears of Joy emoji. You may think of it as a smiling face with tears of joy, but you can also can think of it as `\u1F602;`, which is its Unicode code point.

However, Unicode characters aren't the only way to do emoji. Another popular syntax for emoji is `:emoji_name:` -- that is a colon (`:`), followed by the underscore-separated name of the emoji, followed by a colon.

What should Markua do?

Well, first of all, this is *fantastic* news. Emoji are the single legitimate use case for an inline span image, but any syntax I could invent to specify alt text on an inline span image was either disgusting or was inconsistent with how images are inserted as figures with figure captions.

So, now that emoji are on the rise and have two syntaxes to support them, this problem is solved: emoji can be inserted using either Unicode entities or the special emoji syntax, and the output generated by a Markua Processor is (hopefully) the emoji. So, there's no need for an inline span image syntax!

Markua handles both emoji syntaxes, but it handles them differently.

For the Unicode entity syntax, you just type the Unicode entity. For example, you could write the following sentence:

~~~
The emoji support in Markua makes me \u1F602;
~~~

Again, as discussed [above](#unicode-entities), there is no requirement for a Markua Processor to support a given Unicode character.

With the `:emoji_name:` syntax, a similar, slightly less happy, sentence would be:

~~~
The emoji support in Markua makes me :smile:.
~~~

When outputting a sentence containing emoji inserted using the `:emoji_name:` syntax, the Markua Processor can either:

1. Output the emoji as a span image (right in the flow of the text with no line breaks before or after it) with the `:emoji_name:` (including the colons) as alt text.
2. Output the emoji using an emoji-aware font, having mapped the emoji name to some Unicode code point using some canonical table somewhere. There are online resources such as <http://www.webpagefx.com/tools/emoji-cheat-sheet/> which may be a starting point for any Markua Processor wishing to do this.
3. Output the `:emoji_name:` as an inline code span showing the `:emoji_name:` verbatim.
4. Output a "missing image" character, if it does not recognize the given emoji.

Because of this, Markua's emoji support can also optionally be used by Markua Processors for a wide range of emoji. For example, a Markua Processor could output Font Awesome icons with an emoji syntax, such as `:fa-leanpub:` to output the Leanpub logo in Font Awesome. Since all Font Awesome icons have an `fa-` prefix, these are namespaced nicely.

## Placeholders

Placeholders are a simple text-replace templating system which allow you to define boilerplate in one place, and easily insert it in other places. For books like novels, these obviously have no place. However, for books, courses and other types of documents produced by large organizations, there is an absolute need for placeholders.

Since this is a fairly niche requirement, the syntax is designed in a way that authors should never inadvertently trigger it unless they intend to. It is similar to the footnote syntax.

Placeholder definitions can occur before or after the placeholder insertions. Implementors of Markua Processors are encouraged to deal with placeholders in a pre-processing step.

Placeholders can be defined and inserted as span or block elements.

### Placeholder Identifiers

The identifier for a placeholder must conform to `/[a-zA-Z][a-zA-Z0-9_-]*/`. That is, it starts with a lowercase or uppercase letter `[a-zA-Z]`, followed by 0 or more letters, numbers, underscores or hyphens `[a-zA-Z0-9_-]*`.

### Span Placeholders

#### Span Placeholder Definition

To define a span placeholder, you create a block element consisting of two opening curly braces (`{{`), followed by the placeholder identifier, followed by two closing curly braces (`}}`), followed by a colon (`:`), followed by one space, followed by the span placeholder definition:

~~~
other stuff

{{a_span_placeholder}}: This is the span placeholder definition which can have **Markua formatting** and reference {{other_span_placeholders}} but not block placeholders.

other stuff
~~~

A span placeholder definition can have Markua formatting and can reference other span placeholders.

However, block placeholder references and circular placeholder references are obviously forbidden as content of span placeholder definitions.

#### Span Placeholder Usage

A span placeholder can then be used either in a span context or in a block context.

Specifically, to insert a span placeholder, you use two opening curly braces (`{{`), followed by the placeholder identifier (composed of `a-zA-Z_-` characters), followed by two closing curly braces (`}}`).

~~~
Here's a span placeholder as the only content of a block:

{{a_span_placeholder}}

Here's the same span placeholder {{a_span_placeholder}} being used in a span context.
~~~

### Block Placeholders

#### Block Placeholder Definition

To define a block placeholder, you create a block element consisting of two opening curly braces (`{{`), followed by the placeholder identifier, followed by two closing curly braces (`}}`), followed by the block placeholder content, followed by a newline, followed by two opening curly braces (`{{`), followed by a forward slash (`/`), followed by the placeholder identifier, followed by two closing curly braces (`}}`):

~~~
other stuff

{{a_block_placeholder}}
This is the placeholder content.

It can include *any type of Markua formatting* and can **even** include {{span_placeholder_references}}.

It can also include block placeholder references:

{{some_other_block_placeholder}}

Note that circular placeholder references are obviously forbidden.
{{/a_block_placeholder}}

other stuff
~~~

#### Block Placeholder Usage

A block placeholder can then be used only in a block context. It cannot be used in a span context.

Specifically, to insert a block placeholder, you use two opening curly braces (`{{`), followed by the placeholder identifier (composed of `a-zA-Z_-` characters), followed by two closing curly braces (`}}`). The only difference is that this must be in a block context by itself, with at least one blank line above or below it.

~~~
Here's a block placeholder as the only content of a block:

{{a_block_placeholder}}

You cannot insert that block placeholder in a span context like in this paragraph.
~~~

{#whitespace-hack}
## A Hack for Forcing Whitespace

Inside a code span or block, whitespace must be preserved by a Markua Processor. So, if you're trying to insert a bunch of whitespace for some strange reason, there is a straightforward hack to do so.

So, there are five spaces between foo and bar here, three inside the backticks, and two outside them: foo `   ` bar. Similarly, there are five blank lines between these two paragraphs:

~~~
Yada yada yada

```



```

Yada yada yada
~~~

You can also use the poetry block syntax, if you want your whitespace to be more poetic:

~~~
Yada yada yada

---



---

Yada yada yada
~~~

Again, this is a total hack. It should not be used to accomplish pagination or otherwise format a Markua document. However, if you want to do it, now you know how to do it.

{#concatenating}
## Concatenating Files and Blank Lines

A Markua document can be written in one file or multiple manuscript files. If a manuscript is written in multiple files, these files are concatenated together by the Markua Processor to produce one temporary manuscript file, and that one file is used as the input.

Importantly, in order to avoid a number of bugs, the files are not just concatenated together unchanged--they **must** be concatenated together by Markua Processors in the following way:

1. All newlines at the beginning and the end of each file are removed.
2. Two newlines are added between the end of each file and the beginning of the next file.

So, after this process, exactly one blank line separates the contents of each manuscript file.

This prevents a number of surprises for authors, and is consistent in design: just as Markua does not support invisible formatting at the end of a line, it does not support invisible formatting at the end of a file.

Note that because of this rule, a paragraph (or any other block element) cannot span multiple manuscript files.

To see why this approach is so important, consider the following single-file Markua document:

{caption: manuscript.txt}
~~~
# Chapter One

Lorem ipsum dolor.

# Chapter Two

Yada yada yada.
~~~

Suppose instead a multiple-file approach was used, in which there were two files, ch1.txt and ch2.txt, with the following content:

{caption: ch1.txt}
~~~
# Chapter One

Lorem ipsum dolor.
~~~

{caption: ch2.txt}
~~~
# Chapter Two

Yada yada yada.
~~~

If Markua did not add any newlines between files, then these files would produce the following incorrect manuscript:

{caption: incorrect concatenation}
~~~
# Chapter One

Lorem ipsum dolor.# Chapter Two

Yada yada yada.
~~~

If Markua only added one newline when concatenating, this would produce the following incorrect manuscript:

{caption: also incorrect concatenation}
~~~
# Chapter One

Lorem ipsum dolor.
# Chapter Two

Yada yada yada.
~~~

However, since Markua requires that headings be separated by blank lines above and below them, the Chapter Two heading would not be a heading. It would be considered part of the previous paragraph! This would be very surprising and the source of a number of bugs. Worse, since a number of text editors such as Emacs have a "strip blank lines at the end of files" setting, it would be possible to introduce such a bug if Markua simply relied on blank lines being added to the end of a file by the author.

So, because of the blank line rule, concatenating the files produces the same manuscript as the single-file manuscript above:

{caption: correct concatenation}
~~~
# Chapter One

Lorem ipsum dolor.

# Chapter Two

Yada yada yada.
~~~

